<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>çº¢ç‚¹è¿½è¿½å–µï¼šé™¤å°˜ç‰¹å·¥é˜Ÿ - Proç‰ˆ</title>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Varela+Round&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #fff8fb;
            --brand-1: #ff8fab;
            --brand-2: #c5a9ff;
            --brand-3: #fdd5f2;
            --brand-4: #ffd3b6;
            --brand-5: #a8e6cf;
            --ink-dark: #6d6875;
            --ink-muted: #b4a7d6;
            --card-bg: rgba(255, 255, 255, 0.95);
            --shadow-sm: 0 12px 28px rgba(229, 192, 222, 0.3);
            --shadow-lg: 0 30px 80px rgba(255, 143, 171, 0.35);
        }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body {
            margin: 0; background: var(--bg-color);
            font-family: 'Varela Round', 'Segoe UI', sans-serif;
            color: var(--ink-dark); overflow: hidden; user-select: none; cursor: none;
        }
        body.prestart { cursor: auto; }
        #cursor {
            position: fixed; width: 22px; height: 22px; border-radius: 50%;
            background: radial-gradient(circle at center, rgba(255, 237, 242, 0.9), rgba(255, 143, 171, 0.8));
            border: 2px solid rgba(255, 143, 171, 0.8); pointer-events: none;
            transform: translate(-50%, -50%); transition: transform 0.05s linear; z-index: 999;
            box-shadow: 0 0 22px rgba(255, 143, 171, 0.6);
            animation: cursorPulse 2s infinite alternate;
        }
        #game-container {
            position: relative; width: 100vw; height: 100vh;
            display: flex; justify-content: center; align-items: center; padding: 18px;
            background: radial-gradient(circle at center, #fffafc 0%, #ffeaf1 100%);
            overflow: hidden;
        }
        #gameCanvas {
            background: transparent; 
            border-radius: 28px;
            border: 10px solid rgba(255, 255, 255, 0.92);
            box-shadow: var(--shadow-lg); display: block; max-width: 100%;
            position: absolute; /* ç¡®ä¿ç”»å¸ƒç»å¯¹å®šä½ */
            z-index: 1;
        }
        #effectsCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 2;
        }
        #ui-layer {
            position: absolute; inset: 0; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between; padding: 20px 24px;
            z-index: 10;
        }
        /* ===== ç™»å½•/æ³¨å†Œç•Œé¢æ ·å¼ ===== */
.auth-container {
  position: absolute;
  inset: 0;
  background: var(--bg-color);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 30;
  animation: fadeIn 0.5s ease-out;
}
.auth-card {
  background: var(--card-bg);
  padding: 30px;
  border-radius: 28px;
  border: 4px solid rgba(255, 255, 255, 0.9);
  box-shadow: var(--shadow-lg);
  width: min(400px, 90vw);
  text-align: center;
}
.auth-title {
  font-family: 'Fredoka One', cursive;
  font-size: 32px;
  color: var(--brand-1);
  margin: 0 0 10px;
  text-shadow: 0 0 15px rgba(255, 143, 171, 0.5);
}
.auth-tabs {
  display: flex;
  gap: 10px;
  margin-bottom: 20px;
  justify-content: center;
}
.auth-tab {
  padding: 8px 16px;
  border: none;
  background: rgba(197, 169, 255, 0.2);
  color: var(--brand-2);
  border-radius: 16px;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.2s;
}
.auth-tab.active {
  background: var(--brand-2);
  color: white;
  transform: scale(1.05);
}
.auth-form {
  display: flex;
  flex-direction: column;
  gap: 12px;
}
.auth-form input {
  padding: 12px 16px;
  border: 2px solid rgba(197, 169, 255, 0.5);
  border-radius: 16px;
  background: rgba(255, 255, 255, 0.9);
  font-size: 16px;
  outline: none;
  transition: border-color 0.2s;
}
.auth-form input:focus {
  border-color: var(--brand-2);
}
.auth-btn {
  padding: 12px;
  border: none;
  border-radius: 999px;
  background: linear-gradient(135deg, var(--brand-1), #ffb2ca);
  color: white;
  font-family: 'Fredoka One', cursive;
  font-size: 18px;
  cursor: pointer;
  box-shadow: 0 8px 0 #e87b9b;
  transition: transform 0.1s, box-shadow 0.1s;
}
.auth-btn:active {
  transform: translateY(6px);
  box-shadow: 0 2px 0 #e87b9b;
}
        @keyframes cursorPulse {
            0% { transform: translate(-50%, -50%) scale(1); box-shadow: 0 0 22px rgba(255, 143, 171, 0.6); }
            100% { transform: translate(-50%, -50%) scale(1.2); box-shadow: 0 0 35px rgba(255, 143, 171, 0.9); }
        }
        
        @keyframes screenShake {
            0%, 100% { transform: translate(0, 0); }
            10%, 30%, 50%, 70%, 90% { transform: translate(-5px, 5px); }
            20%, 40%, 60%, 80% { transform: translate(5px, -5px); }
        }
        
        @keyframes hitFlash {
            0% { background-color: rgba(255, 0, 0, 0.3); }
            100% { background-color: transparent; }
        }
        
        @keyframes lightning {
            0% { filter: brightness(1); }
            50% { filter: brightness(3); }
            100% { filter: brightness(1); }
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        
        @keyframes glow {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 143, 171, 0.5); }
            50% { box-shadow: 0 0 40px rgba(255, 143, 171, 0.8); }
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #screen-effects {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
            opacity: 0;
        }
        
        #combo-effects {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 5;
        }
        
        #bullet-hell-container {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 1;
        }
        
        .skill-btn {
            animation: glow 2s infinite ease-in-out;
        }
        
        .phase-chip {
            animation: float 3s infinite ease-in-out;
        }
        
        .combo-display {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            font-family: 'Fredoka One', cursive;
            font-size: 80px;
            color: #ff4081;
            text-shadow: 0 0 30px #ff4081;
            z-index: 100;
            pointer-events: none;
            transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        
        .top-bar { 
            display: flex; 
            justify-content: center; 
            gap: 18px; 
            flex-wrap: wrap; 
            margin-bottom: 8px; 
            margin-top: 10px;
        }
        .status-box {
            display: flex; align-items: center; gap: 12px; padding: 12px 20px;
            background: var(--card-bg); border-radius: 20px;
            border: 2px solid rgba(255, 255, 255, 0.86); box-shadow: var(--shadow-sm);
            min-width: 220px; pointer-events: auto;
            transition: transform 0.3s ease;
        }
        .status-box:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 40px rgba(197, 169, 255, 0.4);
        }
        .status-label { font-weight: 800; color: var(--brand-2); display: flex; align-items: center; gap: 6px; }
        .status-label.boss { color: var(--brand-1); }
        .bar-bg {
            flex: 1; height: 16px; background: rgba(229, 213, 255, 0.65);
            border-radius: 999px; position: relative; overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.9);
        }
        .bar-fill {
            position: absolute; left: 0; top: 0; height: 100%; width: 100%;
            border-radius: 999px; transition: width 0.3s ease-out;
        }
        .meta-bar {
            display: flex; justify-content: center; gap: 14px; flex-wrap: wrap;
            margin-bottom: 15px; pointer-events: auto;
        }
        .phase-chip {
            padding: 10px 22px; border-radius: 26px;
            background: linear-gradient(135deg, rgba(255, 143, 171, 0.95), rgba(255, 178, 203, 0.95));
            color: #fff; font-family: 'Fredoka One', cursive; font-size: 16px;
            box-shadow: 0 12px 25px rgba(255, 143, 171, 0.4);
        }
        .meta-card {
            display: flex; align-items: center; gap: 8px; padding: 10px 18px;
            background: var(--card-bg); border-radius: 18px;
            border: 2px solid rgba(255, 255, 255, 0.9); box-shadow: 0 12px 24px rgba(197, 169, 255, 0.22);
            font-weight: 700; color: var(--ink-dark);
            transition: all 0.3s ease;
        }
        .meta-card:hover {
            transform: scale(1.05);
            box-shadow: 0 20px 40px rgba(197, 169, 255, 0.4);
        }
        .mission-board {
            display: flex; 
            justify-content: center; 
            gap: 18px; 
            flex-wrap: wrap; 
            pointer-events: none;
            margin-bottom: 15px;
        }
        .mission-panel {
            width: 170px;
            background: var(--card-bg); 
            border-radius: 20px; 
            padding: 14px;
            border: 2px solid rgba(255, 255, 255, 0.9); 
            box-shadow: var(--shadow-sm); 
            pointer-events: auto;
            transition: transform 0.3s ease;
            max-height: 180px;
            overflow-y: auto;
        }
        .mission-panel::-webkit-scrollbar {
            width: 4px;
        }
        .mission-panel::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.05);
            border-radius: 2px;
        }
        .mission-panel::-webkit-scrollbar-thumb {
            background: var(--brand-1);
            border-radius: 2px;
        }
        .mission-panel:hover {
            transform: translateY(-5px);
            box-shadow: 0 25px 50px rgba(229, 192, 222, 0.4);
        }
        .mission-panel h3 { 
            margin: 0 0 10px; 
            font-size: 14px;
            color: var(--brand-2); 
            font-weight: 800; 
        }
        .mission-list { 
            list-style: none; 
            margin: 0; 
            padding: 0; 
            display: grid; 
            gap: 8px;
        }
        .mission-item {
            background: rgba(255, 255, 255, 0.7); 
            border-radius: 12px; 
            padding: 8px 10px;
            border: 1px solid rgba(230, 210, 255, 0.7); 
            font-size: 12px;
            position: relative; 
            overflow: hidden;
            transition: all 0.3s ease;
            line-height: 1.3;
        }
        .mission-item:hover {
            transform: translateX(5px);
            background: rgba(255, 255, 255, 0.9);
        }
        .mission-item.complete { 
            background: rgba(168, 230, 207, 0.25); 
            border-color: rgba(168, 230, 207, 0.9);
            animation: pulseComplete 2s infinite;
        }
        @keyframes pulseComplete {
            0%, 100% { background: rgba(168, 230, 207, 0.25); }
            50% { background: rgba(168, 230, 207, 0.5); }
        }
        .skill-wrapper { 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            gap: 8px;
            pointer-events: auto; 
            margin-top: 10px;
        }
        .skill-btn {
            width: 90px;
            height: 90px;
            border-radius: 28px;
            border: 4px solid rgba(197, 169, 255, 0.95);
            background: linear-gradient(145deg, #ffffff, rgba(255, 242, 250, 0.95));
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            cursor: pointer; box-shadow: 0 10px 0 #d9c8ff, 0 18px 20px rgba(197, 169, 255, 0.35);
            transition: transform 0.15s ease, box-shadow 0.15s ease; position: relative; overflow: hidden;
        }
        .skill-btn:active { transform: translateY(8px); box-shadow: 0 2px 0 #d9c8ff; }
        .skill-btn.cooldown { filter: grayscale(0.8); opacity: 0.6; cursor: not-allowed; }
        .cd-overlay {
            position: absolute; inset: 0; background: rgba(0, 0, 0, 0.22);
            transform-origin: bottom; transform: scaleY(0); transition: transform linear;
        }
        #dialog-box {
            position: absolute; top: 110px; left: 50%; transform: translateX(-50%);
            padding: 14px 24px; background: rgba(255, 255, 255, 0.97);
            border-radius: 26px; border: 3px solid var(--brand-1);
            box-shadow: 0 12px 30px rgba(255, 143, 171, 0.4);
            font-weight: 700; display: none; max-width: 580px; text-align: center;
            animation: popIn 0.4s cubic-bezier(0.18, 0.89, 0.32, 1.28);
            backdrop-filter: blur(10px);
            z-index: 100;
        }
        #start-screen, #end-screen, #pause-screen {
            position: absolute; inset: 0; display: flex; flex-direction: column;
            justify-content: center; align-items: center; background: rgba(255, 248, 251, 0.95);
            backdrop-filter: blur(8px); z-index: 20; pointer-events: auto;
            animation: fadeIn 0.5s ease-out;
        }
        #pause-screen, #end-screen {
            animation: fadeIn 0.5s ease-out;
        }

        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        #start-screen h1 {
            font-family: 'Fredoka One', cursive; font-size: 52px; color: var(--brand-1);
            text-shadow: 3px 3px 0 #ffffff, 0 0 30px rgba(255, 143, 171, 0.5); margin: 0 0 12px;
            animation: glowText 2s infinite alternate;
        }
        @keyframes glowText {
            0% { text-shadow: 3px 3px 0 #ffffff, 0 0 30px rgba(255, 143, 171, 0.5); }
            100% { text-shadow: 3px 3px 0 #ffffff, 0 0 50px rgba(255, 143, 171, 0.8); }
        }
        
        .cat-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 22px; width: min(780px, 90vw); }
        .cat-card {
            background: var(--card-bg); padding: 20px; border-radius: 24px;
            border: 4px solid rgba(255, 255, 255, 0.9); box-shadow: var(--shadow-sm);
            text-align: center; cursor: pointer; transition: transform 0.25s ease, border-color 0.25s ease;
        }
        .cat-card:hover { transform: translateY(-14px); border-color: var(--brand-1); }
        .cat-avatar { font-size: 64px; margin-bottom: 10px; display: inline-block; }
        .badge {
            display: inline-flex; align-items: center; padding: 4px 12px; border-radius: 999px;
            font-size: 12px; font-weight: 700; background: #eee; margin-bottom: 8px;
        }
        .start-btn {
            padding: 14px 44px; border-radius: 999px; border: none;
            background: linear-gradient(135deg, var(--brand-1), #ffb2ca); color: #fff;
            font-family: 'Fredoka One', cursive; font-size: 22px; cursor: pointer;
            box-shadow: 0 12px 0 #e87b9b; transition: transform 0.1s ease, box-shadow 0.1s ease;
            animation: pulseButton 2s infinite;
        }
        @keyframes pulseButton {
            0%, 100% { transform: scale(1); box-shadow: 0 12px 0 #e87b9b; }
            50% { transform: scale(1.05); box-shadow: 0 16px 0 #e87b9b; }
        }
        .start-btn:active { transform: translateY(8px); box-shadow: 0 4px 0 #e87b9b; }
        
        /* æ‘‡æ‘†å°çŒ«æ ·å¼ */
        .swinging-cat-scene {
            position: relative;
            width: 300px;
            height: 300px;
            margin: 0 auto 30px;
        }

        .swinging-cat-all-wrap {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            animation: bob 7s cubic-bezier(0.5, 0, 0.5, 1) infinite both;
        }

        .swinging-cat-all {
            position: absolute;
            width: 5rem;
            height: 5rem;
            transform-origin: center -20rem;
            animation: swing 7s cubic-bezier(0.5, 0, 0.5, 1) infinite both;
        }

        .swinging-cat-all:before {
            content: "";
            position: absolute;
            height: 20rem;
            width: 4px;
            background: linear-gradient(to bottom, #db242a, #ff6b6b);
            left: calc(50% - 2px);
            bottom: 20rem;
            border-radius: 2px;
        }

        .swinging-cat-wrap {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .swinging-cat {
            position: absolute;
            width: 120px;
            height: 180px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .swinging-cat-head {
            position: absolute;
            width: 80px;
            height: 70px;
            background-color: white;
            border-radius: 50% 50% 40% 40%;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .swinging-cat-ear {
            position: absolute;
            width: 0;
            height: 0;
            top: -15px;
            z-index: 11;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            border-bottom: 30px solid white;
        }

        .swinging-cat-ear:before {
            content: "";
            position: absolute;
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-bottom: 22px solid #ffb6c1;
            top: 5px;
            left: -10px;
        }

        .swinging-cat-ear.left {
            left: 5px;
            transform: rotate(-5deg);
        }

        .swinging-cat-ear.right {
            right: 5px;
            transform: rotate(5deg);
        }

        .swinging-cat-body {
            position: absolute;
            width: 85px;
            height: 100px;
            background-color: white;
            border-radius: 45% 45% 40% 40% / 60% 60% 40% 40%;
            top: 45px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 5;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .swinging-cat-body:before {
            content: "";
            position: absolute;
            width: 65px;
            height: 45px;
            background: linear-gradient(to bottom, #ffb6c1, #ff9eb5);
            border-radius: 40% 40% 50% 50% / 60% 60% 40% 40%;
            bottom: -5px;
            left: 50%;
            transform: translateX(-50%);
        }

        .swinging-cat-neck {
            position: absolute;
            width: 40px;
            height: 20px;
            background-color: white;
            top: 55px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 7;
            border-radius: 0 0 10px 10px;
        }

        .swinging-cat-front-hands {
            position: absolute;
            width: 100%;
            height: 60px;
            top: 65px;
            left: 0;
            z-index: 6;
        }

        .swinging-cat-front-hand {
            position: absolute;
            width: 16px;
            height: 35px;
            background-color: white;
            border-radius: 8px;
            top: 15px;
            background: linear-gradient(to right, #d5e8f8, #d5e8f8 20%, #80b9d9);
            z-index: 6;
        }

        .swinging-cat-front-hand.left {
            left: 25px;
            transform: rotate(-5deg);
        }

        .swinging-cat-front-hand.right {
            right: 25px;
            transform: rotate(5deg);
        }

        .swinging-cat-front-hand:after {
            content: "";
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #ffcc00;
            border-radius: 50%;
            bottom: -5px;
            left: 50%;
            transform: translateX(-50%);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .swinging-cat-legs {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform-origin: top center;
            z-index: 1;
        }

        .swinging-cat-leg {
            position: absolute;
            width: 20px;
            height: 75px;
            background-color: white;
            z-index: -1;
            background: linear-gradient(to right, #d5e8f8, #d5e8f8 20%, #80b9d9);
            top: 85px;
            border-radius: 10px 10px 0 0;
        }

        .swinging-cat-leg.left {
            left: 18px;
            transform: rotate(-3deg);
        }

        .swinging-cat-leg.right {
            right: 18px;
            transform: rotate(3deg);
        }

        .swinging-cat-leg:after {
            content: "";
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #ffcc00;
            border-radius: 50%;
            bottom: -5px;
            left: 50%;
            transform: translateX(-50%);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .swinging-cat-lower-wrap {
            height: 90%;
            width: 100%;
            position: absolute;
            top: 100%;
            width: 75px;
            left: calc(50% - 37.5px);
            animation: reverse-swing 7s 0.2s infinite both;
        }

        .swinging-cat-face {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
        }

        .swinging-cat-eye {
            position: absolute;
            width: 14px;
            height: 18px;
            background-color: #4a4a4a;
            border-radius: 50%;
            top: 25px;
            overflow: hidden;
        }

        .swinging-cat-eye:before {
            content: "";
            position: absolute;
            width: 6px;
            height: 6px;
            background-color: white;
            border-radius: 50%;
            top: 4px;
            left: 4px;
        }

        .swinging-cat-eye:after {
            content: "";
            position: absolute;
            width: 8px;
            height: 4px;
            background-color: #ffcc00;
            border-radius: 50%;
            bottom: 2px;
            left: 3px;
        }

        .swinging-cat-eye.left {
            left: 18px;
        }

        .swinging-cat-eye.right {
            right: 18px;
        }

        .swinging-cat-nose {
            position: absolute;
            width: 12px;
            height: 10px;
            background: linear-gradient(to bottom, #ffb6c1, #ff9eb5);
            border-radius: 40% 40% 50% 50%;
            top: 42px;
            left: 50%;
            transform: translateX(-50%);
        }

        .swinging-cat-whisker {
            position: absolute;
            height: 1px;
            background-color: #333;
        }

        .swinging-cat-whisker.left-1 {
            left: 5px;
            width: 20px;
            transform: rotate(15deg);
            top: 45px;
        }

        .swinging-cat-whisker.left-2 {
            left: 5px;
            width: 20px;
            transform: rotate(5deg);
            top: 48px;
        }

        .swinging-cat-whisker.left-3 {
            left: 5px;
            width: 20px;
            transform: rotate(-5deg);
            top: 51px;
        }

        .swinging-cat-whisker.right-1 {
            right: 5px;
            width: 20px;
            transform: rotate(-15deg);
            top: 45px;
        }

        .swinging-cat-whisker.right-2 {
            right: 5px;
            width: 20px;
            transform: rotate(-5deg);
            top: 48px;
        }

        .swinging-cat-whisker.right-3 {
            right: 5px;
            width: 20px;
            transform: rotate(5deg);
            top: 51px;
        }

        .swinging-cat-tail {
            position: absolute;
            width: 16px;
            height: 65px;
            background-color: white;
            border-radius: 8px;
            top: 110px;
            right: -8px;
            transform-origin: top center;
            animation: tail-wag 3s infinite alternate;
            background: linear-gradient(to right, white, #f0f0f0);
            z-index: 4;
        }

        @keyframes swing {
            0%, 100% { transform: rotate(-15deg); }
            50% { transform: rotate(15deg); }
        }

        @keyframes reverse-swing {
            0%, 100% { transform: rotate(15deg); }
            50% { transform: rotate(-15deg); }
        }

        @keyframes bob {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(-10px); }
        }

        @keyframes tail-wag {
            0%, 100% { transform: rotate(-8deg); }
            50% { transform: rotate(8deg); }
        }

        @keyframes jump {
            0%, 100% { transform: translate(-50%, -50%); }
            50% { transform: translate(-50%, -80%); }
        }

        .jumping {
            animation: jump 0.5s ease-in-out;
        }
        
        @keyframes popIn { from { opacity: 0; transform: translate(-50%, 20px) scale(0.8); } to { opacity: 1; transform: translate(-50%, 0) scale(1); } }
        
        #pause-screen { display: none; }
        .pause-menu {
            background: var(--card-bg); padding: 30px; border-radius: 24px;
            border: 4px solid rgba(255, 255, 255, 0.9); box-shadow: var(--shadow-sm);
            text-align: center; min-width: 300px;
            animation: popIn 0.5s ease-out;
        }
        .pause-menu h2 { color: var(--brand-1); font-family: 'Fredoka One', cursive; margin-top: 0; }
        .menu-btn {
            display: block; width: 100%; padding: 12px; margin: 10px 0;
            background: linear-gradient(135deg, var(--brand-2), #d9c8ff); color: #fff;
            border: none; border-radius: 999px; font-family: 'Fredoka One', cursive;
            font-size: 16px; cursor: pointer; transition: transform 0.1s ease;
        }
        .menu-btn:active { transform: scale(0.95); }
        .achievement-popup {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: var(--card-bg); padding: 20px; border-radius: 20px;
            box-shadow: var(--shadow-lg); z-index: 1000; text-align: center;
            animation: popIn 0.5s ease-out;
            border: 3px solid #ffeb3b;
        }
        .achievement-popup h3 { color: var(--brand-1); margin: 0 0 10px; }
        .achievement-popup p { margin: 0; color: var(--ink-dark); }
        .volume-control {
            display: flex; align-items: center; gap: 10px; margin: 15px 0;
        }
        .volume-slider {
            flex: 1; height: 8px; background: rgba(197, 169, 255, 0.3);
            border-radius: 4px; outline: none;
        }
        .achievement-badge {
            display: inline-block; padding: 4px 10px; margin: 2px;
            background: #ffeb3b; color: #333; border-radius: 12px;
            font-size: 11px; font-weight: bold;
        }
        
        .damage-number {
            position: absolute;
            font-family: 'Fredoka One', cursive;
            font-size: 24px;
            font-weight: bold;
            color: #ff4081;
            text-shadow: 0 0 10px #ff4081;
            pointer-events: none;
            z-index: 100;
            animation: floatDamage 1s ease-out forwards;
        }
        
        @keyframes floatDamage {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-50px) scale(1.5); opacity: 0; }
        }
        
        .screen-shake {
            animation: screenShake 0.5s ease-out;
        }
        
        .hit-flash {
            animation: hitFlash 0.3s ease-out;
        }
        
        .lightning-flash {
            animation: lightning 0.1s ease-out;
        }
        
        .skill-hotkeys {
            position: absolute;
            right: 15px;
            bottom: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            pointer-events: auto;
            z-index: 11;
        }
        
        .skill-hotkey-btn {
            width: 70px;
            height: 70px;
            border-radius: 18px;
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.9), rgba(245, 245, 255, 0.8));
            border: 3px solid rgba(197, 169, 255, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            box-shadow: 0 6px 0 #d9c8ff, 0 12px 16px rgba(197, 169, 255, 0.3);
            transition: all 0.15s ease;
            font-family: 'Fredoka One', cursive;
            position: relative;
            overflow: hidden;
        }
        
        .skill-hotkey-btn:active {
            transform: translateY(6px);
            box-shadow: 0 2px 0 #d9c8ff;
        }
        
        .skill-hotkey-btn .key {
            font-size: 20px;
            color: var(--brand-1);
            margin-bottom: 2px;
        }
        
        .skill-hotkey-btn .icon {
            font-size: 20px;
        }
        
        .skill-hotkey-btn.cooldown {
            filter: grayscale(0.8);
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .skill-hotkey-cd {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.3);
            transform-origin: bottom;
            transform: scaleY(0);
            transition: transform linear;
        }
        
        .skill-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 6px 10px;
            border-radius: 8px;
            font-size: 11px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 1000;
            white-space: nowrap;
            top: -40px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .skill-hotkey-btn:hover .skill-tooltip {
            opacity: 1;
        }
        
        .time-slow-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(68, 102, 255, 0.3);
            pointer-events: none;
            z-index: 998;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        @media (max-width: 720px) {
            .mission-board { 
                flex-direction: column; 
                align-items: center;
                gap: 12px;
            }
            .mission-panel { 
                width: 100%; 
                max-width: 280px; 
                max-height: 160px;
            }
            .skill-wrapper { 
                order: -1; 
                margin-top: 5px;
                margin-bottom: 5px;
            }
            .skill-btn {
                width: 80px;
                height: 80px;
            }
            #cursor { display: none; }
            body { cursor: auto; }
            .skill-hotkeys {
                right: 8px;
                bottom: 8px;
            }
            .skill-hotkey-btn {
                width: 55px;
                height: 55px;
            }
            .skill-hotkey-btn .key {
                font-size: 16px;
            }
            .skill-hotkey-btn .icon {
                font-size: 16px;
            }
            .skill-tooltip {
                font-size: 10px;
                top: -35px;
            }
            .top-bar {
                gap: 12px;
                margin-top: 5px;
            }
            .status-box {
                min-width: 180px;
                padding: 10px 16px;
            }
            .meta-bar {
                gap: 10px;
                margin-bottom: 10px;
            }
            .meta-card {
                padding: 8px 14px;
                font-size: 14px;
            }
        }
        
        @media (max-width: 480px) {
            .mission-board {
                margin-bottom: 10px;
            }
            .mission-panel {
                max-width: 250px;
                max-height: 140px;
                padding: 12px;
            }
            .mission-panel h3 {
                font-size: 13px;
                margin-bottom: 8px;
            }
            .mission-item {
                padding: 6px 8px;
                font-size: 11px;
            }
            .skill-wrapper {
                gap: 5px;
            }
            .skill-btn {
                width: 70px;
                height: 70px;
                border-radius: 22px;
            }
            .top-bar {
                flex-direction: column;
                align-items: center;
            }
            .status-box {
                width: 90%;
                min-width: unset;
            }
            .meta-bar {
                flex-wrap: nowrap;
                overflow-x: auto;
                padding-bottom: 5px;
                justify-content: flex-start;
            }
            .meta-card {
                flex-shrink: 0;
            }
        }
    </style>
</head>

<body class="prestart">
    <!-- ç™»å½•/æ³¨å†Œç•Œé¢ -->
    <div id="auth-screen" class="auth-container">
        <div class="auth-card">
            <h2 class="auth-title">ğŸ¾ èŒçŒ«å‡ºå‡» Pro</h2>
            <p style="text-align:center;color:var(--ink-muted);margin-bottom:20px;">è¯·å…ˆç™»å½•æˆ–æ³¨å†Œ</p>

            <!-- åˆ‡æ¢æ ‡ç­¾ -->
            <div class="auth-tabs">
                <button class="auth-tab active" data-tab="login">ç™»å½•</button>
                <button class="auth-tab" data-tab="register">æ³¨å†Œ</button>
            </div>

            <!-- ç™»å½•è¡¨å• -->
            <form id="login-form" class="auth-form">
                <input type="text" id="login-username" placeholder="ç”¨æˆ·å" required autocomplete="username" />
                <input type="password" id="login-password" placeholder="å¯†ç " required autocomplete="current-password" />
                <button type="submit" class="auth-btn">ç™»å½•æ¸¸æˆ</button>
            </form>

            <!-- æ³¨å†Œè¡¨å•ï¼ˆé»˜è®¤éšè—ï¼‰ -->
            <form id="register-form" class="auth-form" style="display:none;">
                <input type="text" id="reg-username" placeholder="è®¾ç½®ç”¨æˆ·å" required autocomplete="username" />
                <input type="password" id="reg-password" placeholder="è®¾ç½®å¯†ç " required autocomplete="new-password" />
                <input type="password" id="reg-confirm" placeholder="ç¡®è®¤å¯†ç " required />
                <button type="submit" class="auth-btn">æ³¨å†Œè´¦å·</button>
            </form>

            <p id="auth-message" style="text-align:center;margin-top:12px;font-size:13px;color:#ff8fab;"></p>
        </div>
    </div>
    <div id="cursor"></div>
<div id="screen-effects"></div>
<div id="combo-effects"></div>
<div id="bullet-hell-container"></div>
<div id="time-slow-overlay" class="time-slow-overlay"></div>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <canvas id="effectsCanvas"></canvas>

    <div id="start-screen">
        <h1>ğŸ¾ èŒçŒ«å‡ºå‡» Pro</h1>
        <div style="margin-bottom:30px;color:#888;font-size:18px;text-shadow:0 0 10px rgba(255,143,171,0.5);">å‡çº§ç‰ˆBOSSæˆ˜ Â· ç­–ç•¥æŠ€èƒ½ Â· çˆ½å¿«è¿å‡»</div>
        
        <div style="position:absolute;top:0;left:0;width:100%;height:100%;z-index:-1;overflow:hidden;">
            <canvas id="titleEffects" style="width:100%;height:100%;"></canvas>
        </div>
        
        <div class="swinging-cat-scene">
            <div class="swinging-cat-all-wrap">
                <div class="swinging-cat-all">
                    <div class="swinging-cat-wrap">
                        <div class="swinging-cat">
                            <div class="swinging-cat-head">
                                <div class="swinging-cat-ear left"></div>
                                <div class="swinging-cat-ear right"></div>
                                <div class="swinging-cat-face">
                                    <div class="swinging-cat-eye left"></div>
                                    <div class="swinging-cat-eye right"></div>
                                    <div class="swinging-cat-nose"></div>
                                    <div class="swinging-cat-whisker left-1"></div>
                                    <div class="swinging-cat-whisker left-2"></div>
                                    <div class="swinging-cat-whisker left-3"></div>
                                    <div class="swinging-cat-whisker right-1"></div>
                                    <div class="swinging-cat-whisker right-2"></div>
                                    <div class="swinging-cat-whisker right-3"></div>
                                </div>
                            </div>
                            <div class="swinging-cat-neck"></div>
                            <div class="swinging-cat-body"></div>
                            <div class="swinging-cat-front-hands">
                                <div class="swinging-cat-front-hand left"></div>
                                <div class="swinging-cat-front-hand right"></div>
                            </div>
                            <div class="swinging-cat-legs">
                                <div class="swinging-cat-leg left"></div>
                                <div class="swinging-cat-leg right"></div>
                            </div>
                            <div class="swinging-cat-tail"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="cat-grid">
            <div class="cat-card" onclick="game.init('tao')">
                <div class="cat-avatar">âš¡</div>
                <h3>æ·˜æ·˜</h3>
                <span class="badge" style="color:#ff9800;background:#fff3e0">æé€Ÿå‹</span>
                <p style="font-size:13px;color:#888">æŠ€èƒ½ï¼šé—ªç”µå†²åˆº<br>ç¬é—´æ— æ•Œå¹¶åŠ é€Ÿ</p>
            </div>
            <div class="cat-card" onclick="game.init('guai')">
                <div class="cat-avatar">ğŸ›¡ï¸</div>
                <h3>ä¹–ä¹–</h3>
                <span class="badge" style="color:#558b2f;background:#dcedc8">é˜²å¾¡å‹</span>
                <p style="font-size:13px;color:#888">æŠ€èƒ½ï¼šçº¸ç®±å ¡å’<br>åŸåœ°æ— æ•Œå›è¡€</p>
            </div>
            <div class="cat-card" onclick="game.init('qi')">
                <div class="cat-avatar">ğŸ”</div>
                <h3>å¥‡å¥‡</h3>
                <span class="badge" style="color:#673ab7;background:#ede7f6">æˆ˜æœ¯å‹</span>
                <p style="font-size:13px;color:#888">æŠ€èƒ½ï¼šå¼±ç‚¹æ´å¯Ÿ<br>å…¨å±æœºå…³æš´å‡»</p>
            </div>
        </div>
        
        <div style="margin-top: 20px;">
            <div class="volume-control">
                <span>ğŸ”Š éŸ³é‡:</span>
                <input type="range" min="0" max="100" value="50" class="volume-slider" id="volume-slider">
            </div>
        </div>
        
        <button class="start-btn" onclick="game.init('tao')" style="margin-top:30px;">å¼€å§‹æ¸¸æˆ</button>
        
        <div style="margin-top: 30px; max-width: 600px; text-align: left; background: rgba(255,255,255,0.7); padding: 20px; border-radius: 20px;">
            <h3 style="color: var(--brand-1); margin-top: 0;">ğŸ® æŠ€èƒ½ç³»ç»Ÿè¯´æ˜</h3>
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px;">
                <div>
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 5px;">
                        <span style="background: #c084fc; color: white; padding: 2px 8px; border-radius: 10px;">1</span>
                        <strong>å½±åˆ†èº«</strong>
                    </div>
                    <p style="font-size: 12px; color: #666; margin: 0;">å¬å”¤åˆ†èº«ååŠ©æ”»å‡»</p>
                </div>
                <div>
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 5px;">
                        <span style="background: #ffe066; color: #333; padding: 2px 8px; border-radius: 10px;">2</span>
                        <strong>æŠ¤ç›¾</strong>
                    </div>
                    <p style="font-size: 12px; color: #666; margin: 0;">å¸æ”¶ä¼¤å®³ï¼Œä¿æŠ¤çŒ«å’ª</p>
                </div>
                <div>
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 5px;">
                        <span style="background: #4466ff; color: white; padding: 2px 8px; border-radius: 10px;">3</span>
                        <strong>æ—¶é—´å‡ç¼“</strong>
                    </div>
                    <p style="font-size: 12px; color: #666; margin: 0;">å‡æ…¢å…¨åœºæ—¶é—´æµé€Ÿ</p>
                </div>
            </div>
            <p style="font-size: 12px; color: #666; margin-top: 10px;">ä½¿ç”¨é”®ç›˜ 1ã€2ã€3 é”®æˆ–ç‚¹å‡»å³ä¸‹è§’æŠ€èƒ½æŒ‰é’®é‡Šæ”¾æŠ€èƒ½</p>
        </div>
    </div>

    <div id="pause-screen">
        <div class="pause-menu">
            <h2>æ¸¸æˆæš‚åœ</h2>
            <button class="menu-btn" onclick="game.togglePause()">ç»§ç»­æ¸¸æˆ</button>
            <button class="menu-btn" onclick="game.restart()">é‡æ–°å¼€å§‹</button>
            <button class="menu-btn" onclick="game.showAchievements()">æŸ¥çœ‹æˆå°±</button>
            <button class="menu-btn" onclick="game.returnToMainMenu()">è¿”å›ä¸»èœå•</button>
            
            <div class="volume-control">
                <span>ğŸ”Š éŸ³é‡:</span>
                <input type="range" min="0" max="100" value="50" class="volume-slider" id="pause-volume-slider">
            </div>
        </div>
    </div>

    <div id="end-screen" style="display:none">
        <div class="mission-panel" style="width:400px;text-align:center">
            <h1 id="end-title" style="color:var(--brand-1);font-family:'Fredoka One', cursive;">ğŸ‰ èƒœåˆ©ï¼</h1>
            <p id="end-desc">ç°å°˜å°æ€ªå…½è¢«èµ¶è·‘äº†ï¼</p>
            <div style="display:flex;justify-content:center;gap:15px;margin:20px 0;">
                <div class="badge">å¾—åˆ† <span id="res-score">0</span></div>
                <div class="badge">ç”¨æ—¶ <span id="res-time">0s</span></div>
                <div class="badge">ç­‰çº§ <span id="res-level">1</span></div>
            </div>
            <button class="start-btn" onclick="game.restart()">å†æ¥ä¸€å±€</button>
            <button class="menu-btn" style="margin-top:10px;" onclick="game.showAchievements()">æŸ¥çœ‹æˆå°±</button>
            <button class="menu-btn" style="margin-top:10px;" onclick="game.returnToMainMenu()">è¿”å›ä¸»èœå•</button>
        </div>
    </div>

    <div id="ui-layer">
        <div class="top-bar">
            <div class="status-box">
                <span class="status-label boss">ğŸ‘¾ ç°å°˜å°æ€ªå…½</span>
                <div class="bar-bg"><div class="bar-fill" id="boss-hp" style="background:linear-gradient(90deg, #ff8080, #ff4f81);"></div></div>
            </div>
            <div class="status-box">
                <span class="status-label">ğŸ± çŒ«å’ªç”Ÿå‘½</span>
                <div class="bar-bg"><div class="bar-fill" id="cat-hp" style="background:linear-gradient(90deg, #a8e6cf, #88d8b0);"></div></div>
            </div>
            <div class="status-box">
                <span class="status-label">âš¡ èƒ½é‡</span>
                <div class="bar-bg"><div class="bar-fill" id="laser-energy" style="background:linear-gradient(90deg, #c5a9ff, #fbc2eb);"></div></div>
            </div>
        </div>

        <div class="meta-bar">
            <div class="phase-chip" id="phase-chip">é˜¶æ®µ 1</div>
            <div class="meta-card">â­ <span id="score">0</span></div>
            <div class="meta-card">ğŸ”¥ <span id="combo">0</span></div>
            <div class="meta-card">ğŸ± Lv.<span id="cat-level">1</span></div>
            <div class="meta-card" style="cursor:pointer;" onclick="game.togglePause()">â¸ï¸ æš‚åœ</div>
        </div>

        <div id="dialog-box"></div>

        <div class="mission-board">
            <div class="mission-panel">
                <h3>ğŸ¯ ä»»åŠ¡ç›®æ ‡</h3>
                <ul class="mission-list" id="mission-list"></ul>
            </div>
            <div class="skill-wrapper">
                <div class="skill-btn" id="skill-btn" onclick="game.triggerSkill()">
                    <span style="font-size:30px" id="skill-icon">ğŸ¾</span>
                    <span style="font-size:12px;font-weight:800;color:var(--brand-2)">å¤§æ‹›</span>
                    <div class="cd-overlay" id="skill-cd"></div>
                </div>
                <div style="font-size:11px;color:#999">ç©ºæ ¼é”® / ç‚¹å‡»é‡Šæ”¾</div>
            </div>
            <div class="mission-panel">
                <h3>ğŸ’¡ æˆ˜æ–—è´´å£«</h3>
                <div style="font-size:11px;color:#888;line-height:1.4;">
                    1. æ”¶é›†é±¼å¹²å’Œç‰›å¥¶æ¢å¤ç”Ÿå‘½å€¼ã€‚<br>
                    2. æ¿€å…‰èƒ½é‡ä¼šè‡ªåŠ¨æ¢å¤ï¼Œæ— éœ€æ‹…å¿ƒè€—å°½ã€‚<br>
                    3. è§¦å‘åœºæ™¯æœºå…³å¯é€ æˆå¤§é‡ä¼¤å®³ã€‚<br>
                    4. ä¿æŒè¿å‡»å¯è·å¾—åˆ†æ•°åŠ æˆã€‚<br>
                    5. å°å¿ƒç°å°˜å°æ€ªå…½çš„åˆ†èº«æ”»å‡»ï¼<br>
                    6. æŒ‰Pé”®æˆ–ç‚¹å‡»æš‚åœæŒ‰é’®æš‚åœæ¸¸æˆ<br>
                    7. <strong>æŠ€èƒ½æŒ‰é”®ï¼š1-å½±åˆ†èº«ï¼Œ2-æŠ¤ç›¾ï¼Œ3-æ—¶é—´å‡ç¼“</strong>
                </div>
            </div>
        </div>
        
        <div class="skill-hotkeys">
            <div class="skill-hotkey-btn" onclick="SkillSystem.useClone(game.cat)" data-tooltip="å½±åˆ†èº« - å¬å”¤åˆ†èº«ååŠ©æ”»å‡»">
                <div class="key">1</div>
                <div class="icon">ğŸŒ€</div>
                <div class="skill-tooltip">å½±åˆ†èº«<br>å†·å´: 4ç§’</div>
                <div class="skill-hotkey-cd" id="skill-cd-1"></div>
            </div>
            <div class="skill-hotkey-btn" onclick="SkillSystem.useShield(game.cat)" data-tooltip="æŠ¤ç›¾ - å¸æ”¶ä¼¤å®³ä¿æŠ¤çŒ«å’ª">
                <div class="key">2</div>
                <div class="icon">ğŸ›¡ï¸</div>
                <div class="skill-tooltip">æŠ¤ç›¾<br>å†·å´: 6ç§’</div>
                <div class="skill-hotkey-cd" id="skill-cd-2"></div>
            </div>
            <div class="skill-hotkey-btn" onclick="SkillSystem.useSlow()" data-tooltip="æ—¶é—´å‡ç¼“ - å‡æ…¢å…¨åœºæ—¶é—´æµé€Ÿ">
                <div class="key">3</div>
                <div class="icon">â³</div>
                <div class="skill-tooltip">æ—¶é—´å‡ç¼“<br>å†·å´: 8ç§’</div>
                <div class="skill-hotkey-cd" id="skill-cd-3"></div>
            </div>
        </div>
    </div>
</div>

<script>
// =========================
//     æŠ€èƒ½ç³»ç»Ÿ SkillSystem
// =========================

// é¢„åŠ è½½çŒ«å’ªå›¾ç‰‡
const catImages = {
  tao: null,
  guai: null,
  qi: null
};

function loadCatImages() {
  const imagePaths = {
    tao: './images/maodie.png',
    guai: './images/shushu.png',
    qi: './images/xihai.png'
  };

  let loadedCount = 0;
  const total = Object.keys(imagePaths).length;

  for (const key in imagePaths) {
    const img = new Image();
    img.src = imagePaths[key];
    img.onload = () => {
      catImages[key] = img;
      loadedCount++;
      if (loadedCount === total) {
        console.log('æ‰€æœ‰çŒ«å’ªå›¾ç‰‡åŠ è½½å®Œæˆ');
      }
    };
    img.onerror = () => {
      console.warn(`å›¾ç‰‡åŠ è½½å¤±è´¥: ${imagePaths[key]}`);
      // å¦‚æœåŠ è½½å¤±è´¥ï¼Œä»å¯å›é€€åˆ°åŸç»˜åˆ¶é€»è¾‘
    };
  }
}

// é¡µé¢åŠ è½½æ—¶å¼€å§‹åŠ è½½
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', loadCatImages);
} else {
  loadCatImages();
}

const SkillSystem = {
    cd: {
        clone: 240,   // å½±åˆ†èº«å†·å´ï¼ˆ4ç§’ï¼‰
        shield: 360,  // æŠ¤ç›¾å†·å´ï¼ˆ6ç§’ï¼‰
        slow: 480     // æ…¢åŠ¨ä½œå†·å´ï¼ˆ8ç§’ï¼‰
    },
    timer: {
        clone: 0,
        shield: 0,
        slow: 0
    },
    active: {
        shield: false,
        slow: false
    },
    cloneParticles: [],

    update() {
        // å†·å´å€’è®¡æ—¶
        for (let key in this.timer) {
            if (this.timer[key] > 0) this.timer[key]--;
        }
        
        // æ›´æ–°UIå†·å´æ˜¾ç¤º
        this.updateSkillUI();

        // æ…¢åŠ¨ä½œç»“æŸ
        if (this.active.slow && this.timer.slow < 360) {
            this.active.slow = false;
            game.timeScale = 1.0;
            document.getElementById('time-slow-overlay').style.opacity = '0';
        }
        
        // æ›´æ–°å½±åˆ†èº«ç²’å­
        this.updateCloneParticles();
    },
    
    updateCloneParticles() {
        for (let i = this.cloneParticles.length - 1; i >= 0; i--) {
            this.cloneParticles[i].life--;
            if (this.cloneParticles[i].life <= 0) {
                this.cloneParticles.splice(i, 1);
            }
        }
    },
    
    updateSkillUI() {
        const skillButtons = document.querySelectorAll('.skill-hotkey-btn');
        skillButtons.forEach((btn, index) => {
            const cdKeys = ['clone', 'shield', 'slow'];
            const cdKey = cdKeys[index];
            const cdOverlay = btn.querySelector('.skill-hotkey-cd');
            
            if (this.timer[cdKey] > 0) {
                btn.classList.add('cooldown');
                const cdRatio = this.timer[cdKey] / this.cd[cdKey];
                if (cdOverlay) cdOverlay.style.transform = `scaleY(${cdRatio})`;
                
                const tooltip = btn.querySelector('.skill-tooltip');
                const seconds = Math.ceil(this.timer[cdKey] / 60);
                if (tooltip) tooltip.innerHTML = `${this.getSkillName(cdKey)}<br>å†·å´ä¸­: ${seconds}ç§’`;
            } else {
                btn.classList.remove('cooldown');
                if (cdOverlay) cdOverlay.style.transform = 'scaleY(0)';
                
                const tooltip = btn.querySelector('.skill-tooltip');
                if (tooltip) tooltip.innerHTML = `${this.getSkillName(cdKey)}<br>å†·å´: ${Math.ceil(this.cd[cdKey]/60)}ç§’`;
            }
        });
    },
    
    getSkillName(key) {
        const names = {
            clone: 'å½±åˆ†èº«',
            shield: 'æŠ¤ç›¾',
            slow: 'æ—¶é—´å‡ç¼“'
        };
        return names[key];
    },

    useClone(cat) {
        if (!game || !game.active || game.paused) return;
        if (this.timer.clone > 0) {
            game.showDialog("æŠ€èƒ½å†·å´ä¸­...");
            return;
        }

        this.timer.clone = this.cd.clone;
        game.showDialog("ğŸŒ€ å½±åˆ†èº«å‡ºç°ï¼");

        const cloneCount = 2 + Math.floor(game.catProgression.level / 2);
        
        for (let i = 0; i < cloneCount; i++) {
            game.spawnClone(cat.x, cat.y, cat.angle);
        }
        
        game.effects.createCircularWave(cat.x, cat.y, '#c084fc');
        game.audioManager.playSkill();
        
        game.achievementSystem.recordSkillUsage('clone');
        game.checkMission(7, game.missions[6].current + 1);
    },

    useShield(cat) {
        if (!game || !game.active || game.paused) return;
        if (this.timer.shield > 0) {
            game.showDialog("æŠ€èƒ½å†·å´ä¸­...");
            return;
        }

        this.timer.shield = this.cd.shield;
        this.active.shield = true;

        cat.buffs.invinc = true;
        cat.shieldHp = 30 + game.catProgression.level * 10;
        cat.shieldMaxHp = cat.shieldHp;

        game.showDialog("ğŸ›¡ï¸ æŠ¤ç›¾å¯åŠ¨ï¼");
        game.effects.createShieldEffect(cat.x, cat.y);
        game.audioManager.playSkill();
        
        game.achievementSystem.recordSkillUsage('shield');
        game.checkMission(7, game.missions[6].current + 1);
    },

    useSlow() {
        if (!game || !game.active || game.paused) return;
        if (this.timer.slow > 0) {
            game.showDialog("æŠ€èƒ½å†·å´ä¸­...");
            return;
        }

        this.timer.slow = this.cd.slow;
        this.active.slow = true;

        game.timeScale = 0.4;
        document.getElementById('time-slow-overlay').style.opacity = '1';

        game.showDialog("â³ æ—¶é—´æµé€Ÿé™ä½ï¼");
        game.audioManager.playSkill();
        
        game.achievementSystem.recordSkillUsage('slow');
        game.checkMission(7, game.missions[6].current + 1);
    }
};

// =========================
//     å½±åˆ†èº«ç±» CloneCat
// =========================
class CloneCat {
    constructor(x, y, angle) {
        this.x = x; this.y = y;
        this.angle = angle;
        this.life = 180;
        this.opacity = 0.6;
        this.scale = 0.8 + Math.random() * 0.4;
        this.color = '#c084fc';
        this.targetAngle = angle;
        this.speed = 3;
        this.direction = Math.random() * Math.PI * 2;
        this.distance = 50 + Math.random() * 100;
        this.attackTimer = 0;
        this.attackInterval = 30;
    }

    update(cat) {
        this.life--;
        if (this.life <= 0) return false;

        this.direction += 0.02;
        this.x = cat.x + Math.cos(this.direction) * this.distance;
        this.y = cat.y + Math.sin(this.direction) * this.distance;
        
        this.angle += (this.targetAngle - this.angle) * 0.1;
        
        this.attackTimer++;
        if (this.attackTimer >= this.attackInterval) {
            this.attackTimer = 0;
            this.attackBoss();
        }

        return true;
    }
    
    attackBoss() {
        if (!game.boss || game.boss.hp <= 0) return;
        
        const dx = game.boss.x - this.x;
        const dy = game.boss.y - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < 200) {
            game.boss.takeDamage(5 + Math.floor(game.catProgression.level / 2));
            game.effects.createLaserTrail(this.x, this.y, '#c084fc');
        }
    }

    draw() {
        ctx.save();
        ctx.globalAlpha = this.opacity * (this.life / 180);
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.scale(this.scale, this.scale);

        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.ellipse(0, 0, 20, 16, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.beginPath();
        ctx.ellipse(20, 0, 16, 14, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.ellipse(26, -4, 1.5, 2, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.beginPath();
        ctx.ellipse(14, -4, 1.5, 2, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }
}

// --- æ¸¸æˆé…ç½® ---
const CONFIG = { width: 1000, height: 600 };

// å…¨å±€å˜é‡å£°æ˜
let canvas, ctx, ui, game;

// --- é«˜çº§ç‰¹æ•ˆç³»ç»Ÿ ---
class AdvancedEffects {
    constructor() {
        this.effectsCtx = null;
        this.screenEffects = document.getElementById('screen-effects');
        this.comboEffects = document.getElementById('combo-effects');
        this.bulletHellContainer = document.getElementById('bullet-hell-container');
    }
    
    init() {
        const effectsCanvas = document.getElementById('effectsCanvas');
        if (effectsCanvas) {
            this.effectsCtx = effectsCanvas.getContext('2d');
            this.resize();
            window.addEventListener('resize', () => this.resize());
        }
    }
    
    resize() {
        const effectsCanvas = document.getElementById('effectsCanvas');
        if (effectsCanvas && canvas) {
            effectsCanvas.width = canvas.width;
            effectsCanvas.height = canvas.height;
        }
    }
    
    screenShake(intensity = 5, duration = 500) {
        const gameContainer = document.getElementById('game-container');
        if (!gameContainer) return;
        
        gameContainer.classList.add('screen-shake');
        gameContainer.style.animationDuration = `${duration}ms`;
        
        setTimeout(() => {
            gameContainer.classList.remove('screen-shake');
        }, duration);
    }
    
    hitFlash(color = 'rgba(255, 0, 0, 0.3)') {
        const screenEffects = document.getElementById('screen-effects');
        if (!screenEffects) return;
        
        screenEffects.style.background = color;
        screenEffects.style.animation = 'hitFlash 0.3s ease-out';
        screenEffects.style.opacity = '1';
        
        setTimeout(() => {
            screenEffects.style.opacity = '0';
        }, 300);
    }
    
    lightningFlash() {
        const screenEffects = document.getElementById('screen-effects');
        if (!screenEffects) return;
        
        screenEffects.style.animation = 'lightning 0.1s ease-out';
        screenEffects.style.opacity = '1';
        
        setTimeout(() => {
            screenEffects.style.opacity = '0';
        }, 100);
    }
    
    comboEffect(combo) {
        if (combo < 5) return;
        
        const comboDisplay = document.createElement('div');
        comboDisplay.className = 'combo-display';
        comboDisplay.textContent = `${combo} COMBO!`;
        
        let color, shadowColor, size;
        if (combo >= 30) {
            color = '#ff4081';
            shadowColor = '#ff4081';
            size = 100;
        } else if (combo >= 20) {
            color = '#ff9800';
            shadowColor = '#ff9800';
            size = 90;
        } else if (combo >= 10) {
            color = '#00bcd4';
            shadowColor = '#00bcd4';
            size = 80;
        } else {
            color = '#4caf50';
            shadowColor = '#4caf50';
            size = 70;
        }
        
        comboDisplay.style.color = color;
        comboDisplay.style.textShadow = `0 0 30px ${shadowColor}`;
        comboDisplay.style.fontSize = `${size}px`;
        
        this.comboEffects.appendChild(comboDisplay);
        
        requestAnimationFrame(() => {
            comboDisplay.style.transform = 'translate(-50%, -50%) scale(1)';
            this.createComboParticles(combo);
        });
        
        setTimeout(() => {
            comboDisplay.style.transform = 'translate(-50%, -50%) scale(0)';
            setTimeout(() => {
                if (comboDisplay.parentNode) {
                    comboDisplay.parentNode.removeChild(comboDisplay);
                }
            }, 300);
        }, 1000);
    }
    
    createComboParticles(combo) {
        const particleCount = Math.min(50, combo * 2);
        const colors = ['#ff4081', '#ff9800', '#00bcd4', '#4caf50', '#9c27b0'];
        
        for (let i = 0; i < particleCount; i++) {
            const particle = document.createElement('div');
            particle.style.position = 'absolute';
            particle.style.width = '8px';
            particle.style.height = '8px';
            particle.style.borderRadius = '50%';
            particle.style.background = colors[Math.floor(Math.random() * colors.length)];
            particle.style.left = '50%';
            particle.style.top = '50%';
            particle.style.transform = 'translate(-50%, -50%)';
            particle.style.boxShadow = '0 0 10px currentColor';
            
            this.comboEffects.appendChild(particle);
            
            const angle = Math.random() * Math.PI * 2;
            const distance = 100 + Math.random() * 200;
            const duration = 500 + Math.random() * 500;
            
            particle.animate([
                {
                    transform: 'translate(-50%, -50%) scale(1)',
                    opacity: 1
                },
                {
                    transform: `translate(${Math.cos(angle) * distance}px, ${Math.sin(angle) * distance}px) scale(0)`,
                    opacity: 0
                }
            ], {
                duration: duration,
                easing: 'cubic-bezier(0.215, 0.610, 0.355, 1)'
            });
            
            setTimeout(() => {
                if (particle.parentNode) {
                    particle.parentNode.removeChild(particle);
                }
            }, duration);
        }
    }
    
    showDamageNumber(x, y, damage, isCritical = false) {
        const damageNumber = document.createElement('div');
        damageNumber.className = 'damage-number';
        damageNumber.textContent = Math.floor(damage);
        damageNumber.style.left = `${x}px`;
        damageNumber.style.top = `${y}px`;
        
        if (isCritical) {
            damageNumber.style.color = '#ffeb3b';
            damageNumber.style.textShadow = '0 0 20px #ffeb3b';
            damageNumber.style.fontSize = '32px';
        }
        
        const gameContainer = document.getElementById('game-container');
        if (gameContainer) {
            gameContainer.appendChild(damageNumber);
            
            setTimeout(() => {
                if (damageNumber.parentNode) {
                    damageNumber.parentNode.removeChild(damageNumber);
                }
            }, 1000);
        }
    }
    
    createLaserTrail(x, y, color = '#ff8fab') {
        const trail = document.createElement('div');
        trail.style.position = 'absolute';
        trail.style.width = '16px';
        trail.style.height = '16px';
        trail.style.borderRadius = '50%';
        trail.style.background = `radial-gradient(circle at center, ${color}, transparent 70%)`;
        trail.style.left = `${x}px`;
        trail.style.top = `${y}px`;
        trail.style.transform = 'translate(-50%, -50%)';
        trail.style.boxShadow = `0 0 20px ${color}`;
        trail.style.pointerEvents = 'none';
        trail.style.zIndex = '3';
        
        const gameContainer = document.getElementById('game-container');
        if (gameContainer) {
            gameContainer.appendChild(trail);
            
            trail.animate([
                {
                    opacity: 1,
                    transform: 'translate(-50%, -50%) scale(1)'
                },
                {
                    opacity: 0,
                    transform: 'translate(-50%, -50%) scale(0.5)'
                }
            ], {
                duration: 500,
                easing: 'ease-out'
            });
            
            setTimeout(() => {
                if (trail.parentNode) {
                    trail.parentNode.removeChild(trail);
                }
            }, 500);
        }
    }
    
    bossPhaseTransition(phase) {
        this.screenShake(10, 800);
        
        for (let i = 0; i < 5; i++) {
            setTimeout(() => this.lightningFlash(), i * 100);
        }
        
        this.createPhaseParticles(phase);
    }
    
    createPhaseParticles(phase) {
        const particleCount = 200;
        const colors = phase === 3 ? ['#ff5252', '#b71c1c', '#ff8a80'] : 
                      phase === 2 ? ['#ff9800', '#ff5722', '#ffcc80'] : 
                      ['#4caf50', '#8bc34a', '#cddc39'];
        
        const gameContainer = document.getElementById('game-container');
        if (!gameContainer) return;
        
        for (let i = 0; i < particleCount; i++) {
            const particle = document.createElement('div');
            particle.style.position = 'absolute';
            particle.style.width = `${Math.random() * 10 + 5}px`;
            particle.style.height = particle.style.width;
            particle.style.borderRadius = '50%';
            particle.style.background = colors[Math.floor(Math.random() * colors.length)];
            particle.style.left = `${Math.random() * 100}vw`;
            particle.style.top = `${Math.random() * 100}vh`;
            particle.style.boxShadow = '0 0 10px currentColor';
            particle.style.pointerEvents = 'none';
            particle.style.zIndex = '1000';
            
            gameContainer.appendChild(particle);
            
            const angle = Math.random() * Math.PI * 2;
            const distance = 100 + Math.random() * 200;
            const duration = 1000 + Math.random() * 1000;
            
            particle.animate([
                {
                    transform: 'translate(0, 0) scale(1)',
                    opacity: 1
                },
                {
                    transform: `translate(${Math.cos(angle) * distance}px, ${Math.sin(angle) * distance}px) scale(0)`,
                    opacity: 0
                }
            ], {
                duration: duration,
                easing: 'cubic-bezier(0.215, 0.610, 0.355, 1)'
            });
            
            setTimeout(() => {
                if (particle.parentNode) {
                    particle.parentNode.removeChild(particle);
                }
            }, duration);
        }
    }
    
    skillEffect(type, x, y) {
        this.screenShake(3, 300);
        
        let color, particleColor;
        switch(type) {
            case 'dash':
                color = '#ffcc80';
                particleColor = '#ff9800';
                this.createCircularWave(x, y, color);
                break;
            case 'shield':
                color = '#a9def9';
                particleColor = '#4fc3f7';
                this.createShieldEffect(x, y);
                break;
            case 'weakness':
                color = '#e4c1f9';
                particleColor = '#9c27b0';
                this.createWeaknessEffect(x, y);
                break;
        }
        
        const gameContainer = document.getElementById('game-container');
        if (!gameContainer) return;
        
        for (let i = 0; i < 30; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * 100 + 50;
            const particle = document.createElement('div');
            particle.style.position = 'absolute';
            particle.style.width = '10px';
            particle.style.height = '10px';
            particle.style.borderRadius = '50%';
            particle.style.background = particleColor;
            particle.style.left = `${x}px`;
            particle.style.top = `${y}px`;
            particle.style.boxShadow = `0 0 10px ${particleColor}`;
            
            gameContainer.appendChild(particle);
            
            particle.animate([
                {
                    transform: 'translate(0, 0) scale(1)',
                    opacity: 1
                },
                {
                    transform: `translate(${Math.cos(angle) * distance}px, ${Math.sin(angle) * distance}px) scale(0)`,
                    opacity: 0
                }
            ], {
                duration: 800,
                easing: 'ease-out'
            });
            
            setTimeout(() => {
                if (particle.parentNode) {
                    particle.parentNode.removeChild(particle);
                }
            }, 800);
        }
    }
    
    createCircularWave(x, y, color) {
        const gameContainer = document.getElementById('game-container');
        if (!gameContainer) return;
        
        for (let i = 0; i < 3; i++) {
            const wave = document.createElement('div');
            wave.style.position = 'absolute';
            wave.style.width = '0px';
            wave.style.height = '0px';
            wave.style.borderRadius = '50%';
            wave.style.border = `2px solid ${color}`;
            wave.style.left = `${x}px`;
            wave.style.top = `${y}px`;
            wave.style.transform = 'translate(-50%, -50%)';
            wave.style.boxShadow = `0 0 20px ${color}`;
            
            gameContainer.appendChild(wave);
            
            wave.animate([
                {
                    width: '0px',
                    height: '0px',
                    opacity: 1
                },
                {
                    width: '300px',
                    height: '300px',
                    opacity: 0
                }
            ], {
                duration: 1000,
                delay: i * 200,
                easing: 'ease-out'
            });
            
            setTimeout(() => {
                if (wave.parentNode) {
                    wave.parentNode.removeChild(wave);
                }
            }, 1000 + i * 200);
        }
    }
    
    createShieldEffect(x, y) {
        const gameContainer = document.getElementById('game-container');
        if (!gameContainer) return;
        
        const shield = document.createElement('div');
        shield.style.position = 'absolute';
        shield.style.width = '150px';
        shield.style.height = '150px';
        shield.style.borderRadius = '50%';
        shield.style.border = '5px solid #4fc3f7';
        shield.style.left = `${x}px`;
        shield.style.top = `${y}px`;
        shield.style.transform = 'translate(-50%, -50%)';
        shield.style.boxShadow = '0 0 50px #4fc3f7';
        
        gameContainer.appendChild(shield);
        
        shield.animate([
            {
                opacity: 1,
                transform: 'translate(-50%, -50%) scale(1)'
            },
            {
                opacity: 0.5,
                transform: 'translate(-50%, -50%) scale(1.2)'
            },
            {
                opacity: 0,
                transform: 'translate(-50%, -50%) scale(1.5)'
            }
        ], {
            duration: 2000,
            easing: 'ease-out'
        });
        
        setTimeout(() => {
            if (shield.parentNode) {
                shield.parentNode.removeChild(shield);
            }
        }, 2000);
    }
    
    createWeaknessEffect(x, y) {
        const gameContainer = document.getElementById('game-container');
        if (!gameContainer) return;
        
        const rings = 5;
        for (let i = 0; i < rings; i++) {
            const ring = document.createElement('div');
            ring.style.position = 'absolute';
            ring.style.width = `${100 + i * 100}px`;
            ring.style.height = ring.style.width;
            ring.style.borderRadius = '50%';
            ring.style.border = '3px dashed #9c27b0';
            ring.style.left = `${x}px`;
            ring.style.top = `${y}px`;
            ring.style.transform = 'translate(-50%, -50%)';
            ring.style.boxShadow = '0 0 30px #9c27b0';
            
            gameContainer.appendChild(ring);
            
            ring.animate([
                {
                    transform: 'translate(-50%, -50%) rotate(0deg)',
                    opacity: 1
                },
                {
                    transform: 'translate(-50%, -50%) rotate(360deg)',
                    opacity: 0
                }
            ], {
                duration: 1500,
                delay: i * 200,
                easing: 'linear'
            });
            
            setTimeout(() => {
                if (ring.parentNode) {
                    ring.parentNode.removeChild(ring);
                }
            }, 1500 + i * 200);
        }
    }
    
    itemCollectEffect(x, y, type) {
        let color;
        switch(type) {
            case 'energy': color = '#a8e6cf'; break;
            case 'health': color = '#ff8fab'; break;
            case 'speed': color = '#ffcc80'; break;
            case 'shield': color = '#a9def9'; break;
        }
        
        const gameContainer = document.getElementById('game-container');
        if (!gameContainer) return;
        
        for (let i = 0; i < 15; i++) {
            const particle = document.createElement('div');
            particle.style.position = 'absolute';
            particle.style.width = '8px';
            particle.style.height = '8px';
            particle.style.borderRadius = '50%';
            particle.style.background = color;
            particle.style.left = `${x}px`;
            particle.style.top = `${y}px`;
            particle.style.boxShadow = `0 0 10px ${color}`;
            
            gameContainer.appendChild(particle);
            
            const angle = Math.random() * Math.PI * 2;
            const distance = 30 + Math.random() * 70;
            
            particle.animate([
                {
                    transform: 'translate(0, 0) scale(1)',
                    opacity: 1
                },
                {
                    transform: `translate(${Math.cos(angle) * distance}px, ${Math.sin(angle) * distance}px) scale(0)`,
                    opacity: 0
                }
            ], {
                duration: 600,
                easing: 'ease-out'
            });
            
            setTimeout(() => {
                if (particle.parentNode) {
                    particle.parentNode.removeChild(particle);
                }
            }, 600);
        }
    }
}

// åˆå§‹åŒ–æ ‡é¢˜ç‰¹æ•ˆ
function initTitleEffects() {
    const canvas = document.getElementById('titleEffects');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    const particles = [];
    const particleCount = 100;
    
    for (let i = 0; i < particleCount; i++) {
        particles.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            size: Math.random() * 5 + 2,
            speedX: Math.random() * 2 - 1,
            speedY: Math.random() * 2 - 1,
            color: `rgba(${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 200)}, 255, ${Math.random() * 0.5 + 0.3})`
        });
    }
    
    function animate() {
        if (!canvas || !ctx) return;
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        particles.forEach(particle => {
            particle.x += particle.speedX;
            particle.y += particle.speedY;
            
            if (particle.x < 0) particle.x = canvas.width;
            if (particle.x > canvas.width) particle.x = 0;
            if (particle.y < 0) particle.y = canvas.height;
            if (particle.y > canvas.height) particle.y = 0;
            
            ctx.beginPath();
            ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
            ctx.fillStyle = particle.color;
            ctx.fill();
            
            particles.forEach(otherParticle => {
                const dx = particle.x - otherParticle.x;
                const dy = particle.y - otherParticle.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 100) {
                    ctx.beginPath();
                    ctx.moveTo(particle.x, particle.y);
                    ctx.lineTo(otherParticle.x, otherParticle.y);
                    ctx.strokeStyle = `rgba(255, 255, 255, ${0.1 * (1 - distance / 100)})`;
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                }
            });
        });
        
        requestAnimationFrame(animate);
    }
    
    animate();
    
    window.addEventListener('resize', () => {
        if (!canvas) return;
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    });
}

// --- æ¸¸æˆæ ¸å¿ƒ ---

// éŸ³æ•ˆç®¡ç†å™¨
class AudioManager {
    constructor() {
        this.audioContext = null;
        this.volume = 0.5;
        this.enabled = false;
        
        const volumeSlider = document.getElementById('volume-slider');
        const pauseVolumeSlider = document.getElementById('pause-volume-slider');
        
        if (volumeSlider) {
            volumeSlider.addEventListener('input', (e) => {
                this.volume = e.target.value / 100;
                if (pauseVolumeSlider) pauseVolumeSlider.value = e.target.value;
            });
        }
        
        if (pauseVolumeSlider) {
            pauseVolumeSlider.addEventListener('input', (e) => {
                this.volume = e.target.value / 100;
                if (volumeSlider) volumeSlider.value = e.target.value;
            });
        }
        
        this.init();
    }
    
    async init() {
        try {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            this.enabled = true;
        } catch (e) {
            console.log('éŸ³é¢‘åˆå§‹åŒ–å¤±è´¥:', e);
            this.enabled = false;
        }
    }
    
    playTone(frequency, duration, type = 'sine') {
        if (!this.enabled || !this.audioContext) return;
        
        try {
            const oscillator = this.audioContext.createOscillator();
            const gainNode = this.audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(this.audioContext.destination);
            
            oscillator.frequency.value = frequency;
            oscillator.type = type;
            
            gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(this.volume, this.audioContext.currentTime + 0.01);
            gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration / 1000);
            
            oscillator.start(this.audioContext.currentTime);
            oscillator.stop(this.audioContext.currentTime + duration / 1000);
        } catch (e) {
            console.log('æ’­æ”¾éŸ³æ•ˆå¤±è´¥:', e);
        }
    }
    
    playHit() { this.playTone(200, 100, 'square'); }
    playCollect() { this.playTone(523, 150, 'sine'); }
    playSkill() { this.playTone(784, 300, 'sawtooth'); }
    playLevelUp() { 
        this.playTone(523, 100, 'sine');
        setTimeout(() => this.playTone(659, 100, 'sine'), 100);
        setTimeout(() => this.playTone(784, 200, 'sine'), 200);
    }
    playGameOver() { 
        this.playTone(220, 300, 'sine');
        setTimeout(() => this.playTone(196, 500, 'sine'), 300);
    }
    playBossHit() { this.playTone(100, 150, 'square'); }
    playHeal() { 
        this.playTone(330, 100, 'sine');
        setTimeout(() => this.playTone(440, 100, 'sine'), 100);
    }
}

// æˆå°±ç³»ç»Ÿ
class AchievementSystem {
    constructor() {
        this.achievements = {
            firstBlood: { 
                name: "åˆæˆ˜å‘Šæ·", 
                desc: "ç¬¬ä¸€æ¬¡å‡»è´¥BOSS", 
                unlocked: false, 
                reward: 1000 
            },
            comboMaster: { 
                name: "è¿å‡»å¤§å¸ˆ", 
                desc: "è¾¾åˆ°50è¿å‡»", 
                unlocked: false, 
                reward: 500 
            },
            collector: { 
                name: "é“å…·æ”¶è—å®¶", 
                desc: "æ”¶é›†æ‰€æœ‰ç±»å‹é“å…·", 
                unlocked: false, 
                reward: 800 
            },
            speedRunner: { 
                name: "é€Ÿåº¦ä¹‹æ˜Ÿ", 
                desc: "60ç§’å†…å‡»è´¥BOSS", 
                unlocked: false, 
                reward: 1200 
            },
            perfectGame: { 
                name: "å®Œç¾é€šå…³", 
                desc: "æ— ä¼¤é€šå…³", 
                unlocked: false, 
                reward: 2000 
            },
            catLover: {
                name: "çŒ«å¥´å¤§å¸ˆ",
                desc: "å°†çŒ«å’ªå‡åˆ°5çº§",
                unlocked: false,
                reward: 1500
            },
            skillMaster: {
                name: "æŠ€èƒ½å¤§å¸ˆ",
                desc: "ä½¿ç”¨æ‰€æœ‰æŠ€èƒ½å„10æ¬¡",
                unlocked: false,
                reward: 2000
            }
        };
        
        this.unlockedCount = 0;
        this.skillUsage = { clone: 0, shield: 0, slow: 0 };
    }
    
    checkAchievements(game) {
        if (!game || !game.boss) return;
        
        if (!this.achievements.firstBlood.unlocked && game.boss.hp <= 0) {
            this.unlockAchievement('firstBlood', game);
        }
        
        if (!this.achievements.comboMaster.unlocked && game.combo >= 50) {
            this.unlockAchievement('comboMaster', game);
        }
        
        if (!this.achievements.speedRunner.unlocked && 
            game.boss.hp <= 0 && 
            (Date.now() - game.startTime) / 1000 <= 60) {
            this.unlockAchievement('speedRunner', game);
        }
        
        if (!this.achievements.perfectGame.unlocked && 
            game.boss.hp <= 0 && 
            game.cat.hp === game.cat.maxHp) {
            this.unlockAchievement('perfectGame', game);
        }
        
        if (!this.achievements.catLover.unlocked && 
            game.catProgression.level >= 5) {
            this.unlockAchievement('catLover', game);
        }
        
        if (!this.achievements.skillMaster.unlocked && 
            this.skillUsage.clone >= 10 && 
            this.skillUsage.shield >= 10 && 
            this.skillUsage.slow >= 10) {
            this.unlockAchievement('skillMaster', game);
        }
    }
    
    recordSkillUsage(skill) {
        if (this.skillUsage[skill] !== undefined) {
            this.skillUsage[skill]++;
            if (game) {
                game.checkMission(7, this.skillUsage.clone + this.skillUsage.shield + this.skillUsage.slow);
            }
        }
    }
    
    unlockAchievement(achievementKey, game) {
        if (!this.achievements[achievementKey]) return;
        
        this.achievements[achievementKey].unlocked = true;
        this.unlockedCount++;
        
        this.showAchievementPopup(this.achievements[achievementKey]);
        
        if (game) {
            game.addScore(this.achievements[achievementKey].reward);
        }
        
        if (game && game.audioManager) {
            game.audioManager.playLevelUp();
        }
    }
    
    showAchievementPopup(achievement) {
        const popup = document.createElement('div');
        popup.className = 'achievement-popup';
        popup.innerHTML = `
            <h3>ğŸ† æˆå°±è§£é”!</h3>
            <p><strong>${achievement.name}</strong></p>
            <p>${achievement.desc}</p>
            <p>+${achievement.reward} åˆ†æ•°</p>
        `;
        
        document.body.appendChild(popup);
        
        setTimeout(() => {
            if (popup.parentNode) {
                popup.parentNode.removeChild(popup);
            }
        }, 3000);
    }
    
    showAchievementsScreen() {
        const achievementScreen = document.createElement('div');
        achievementScreen.style.position = 'fixed';
        achievementScreen.style.top = '0';
        achievementScreen.style.left = '0';
        achievementScreen.style.width = '100%';
        achievementScreen.style.height = '100%';
        achievementScreen.style.background = 'rgba(255, 248, 251, 0.95)';
        achievementScreen.style.backdropFilter = 'blur(8px)';
        achievementScreen.style.zIndex = '1000';
        achievementScreen.style.display = 'flex';
        achievementScreen.style.justifyContent = 'center';
        achievementScreen.style.alignItems = 'center';
        achievementScreen.style.flexDirection = 'column';
        
        let achievementsHTML = '<h2 style="color: var(--brand-1); font-family: \'Fredoka One\', cursive;">ğŸ† æˆå°±ç³»ç»Ÿ</h2>';
        achievementsHTML += `<p>å·²è§£é”: ${this.unlockedCount} / ${Object.keys(this.achievements).length}</p>`;
        achievementsHTML += '<div style="max-width: 500px; max-height: 400px; overflow-y: auto; padding: 20px;">';
        
        Object.values(this.achievements).forEach(achievement => {
            achievementsHTML += `
                <div style="background: ${achievement.unlocked ? 'rgba(168, 230, 207, 0.25)' : 'rgba(255, 255, 255, 0.7)'}; 
                            border-radius: 14px; padding: 15px; margin: 10px 0; 
                            border: 1px solid ${achievement.unlocked ? 'rgba(168, 230, 207, 0.9)' : 'rgba(230, 210, 255, 0.7)'}">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <h4 style="margin: 0; color: var(--brand-2);">${achievement.name}</h4>
                            <p style="margin: 5px 0; font-size: 14px; color: #888;">${achievement.desc}</p>
                        </div>
                        <div style="text-align: right;">
                            ${achievement.unlocked ? 
                                '<span class="achievement-badge">å·²è§£é”</span>' : 
                                '<span style="color: #ccc;">æœªè§£é”</span>'}
                            <div style="font-weight: bold; color: var(--brand-1);">+${achievement.reward} åˆ†</div>
                        </div>
                    </div>
                </div>
            `;
        });
        
        achievementsHTML += '</div>';
        achievementsHTML += '<button class="menu-btn" style="margin-top: 20px;" onclick="this.parentNode.remove()">å…³é—­</button>';
        
        achievementScreen.innerHTML = achievementsHTML;
        document.body.appendChild(achievementScreen);
    }
}

// çŒ«å’ªå…»æˆç³»ç»Ÿ
class CatProgression {
    constructor() {
        this.level = 1;
        this.experience = 0;
        this.experienceToNextLevel = 100;
        this.skillPoints = 0;
        
        this.attributes = {
            speed: { base: 1, bonus: 0 },
            health: { base: 100, bonus: 0 },
            damage: { base: 1, bonus: 0 },
            energy: { base: 1, bonus: 0 }
        };
    }
    
    addExperience(amount) {
        this.experience += amount;
        if (this.experience >= this.experienceToNextLevel) {
            this.levelUp();
        }
    }
    
    levelUp() {
        this.level++;
        this.experience -= this.experienceToNextLevel;
        this.experienceToNextLevel = Math.floor(this.experienceToNextLevel * 1.5);
        this.skillPoints += 1;
        
        this.attributes.health.base += 10;
        this.attributes.speed.base += 0.1;
        
        if (ui && ui.catLevel) {
            ui.catLevel.innerText = this.level;
        }
        
        if (game) {
            game.showDialog(`ğŸ‰ å‡çº§ï¼å½“å‰ç­‰çº§: ${this.level}`);
            if (game.audioManager) {
                game.audioManager.playLevelUp();
            }
            
            if (game.cat) {
                for (let i = 0; i < 20; i++) {
                    const p = new Particle(game.cat.x, game.cat.y, '#FFD700', 0, 60);
                    p.vx = (Math.random() - 0.5) * 4;
                    p.vy = (Math.random() - 0.5) * 4;
                    p.size = 6;
                    game.particles.push(p);
                }
            }
        }
    }
    
    getSpeedMultiplier() {
        return this.attributes.speed.base + this.attributes.speed.bonus;
    }
    
    getHealthMultiplier() {
        return this.attributes.health.base + this.attributes.health.bonus;
    }
    
    getDamageMultiplier() {
        return this.attributes.damage.base + this.attributes.damage.bonus;
    }
}

// ç®€å•çš„ç²’å­ç³»ç»Ÿ
class Particle {
    constructor(x, y, color, speed, life) {
        this.x = x; this.y = y; this.color = color;
        this.vx = (Math.random() - 0.5) * speed;
        this.vy = (Math.random() - 0.5) * speed;
        this.life = life; this.maxLife = life;
        this.size = Math.random() * 5 + 3;
    }
    update() {
        this.x += this.vx; this.y += this.vy;
        this.vy += 0.05;
        this.life--; this.size *= 0.96;
    }
    draw(ctx) {
        if (!ctx) return;
        ctx.globalAlpha = this.life / this.maxLife;
        ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1;
    }
}

// ç”Ÿå‘½æ¢å¤é“å…·ç±»
class HealthItem {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.size = 18;
        this.life = 300;
        this.maxLife = 300;
        this.collected = false;
        this.speed = Math.random() * 2 + 1;
        this.direction = Math.random() * Math.PI * 2;
        this.rotation = 0;
        this.rotationSpeed = (Math.random() - 0.5) * 0.1;
        this.type = Math.random() > 0.5 ? 'fish' : 'milk';
        this.healthAmount = this.type === 'fish' ? 20 : 15;
    }
    
    update() {
        this.life--;
        if (this.life <= 0) {
            this.collected = true;
        }
        
        this.x += Math.cos(this.direction) * this.speed;
        this.y += Math.sin(this.direction) * this.speed;
        this.rotation += this.rotationSpeed;
        
        if (this.x < this.size || this.x > CONFIG.width - this.size) {
            this.direction = Math.PI - this.direction;
        }
        if (this.y < this.size || this.y > CONFIG.height - this.size) {
            this.direction = -this.direction;
        }
    }
    
    draw() {
        if (!ctx) return;
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        
        ctx.fillStyle = this.type === 'fish' ? '#ffcc80' : '#e0f7fa';
        ctx.beginPath();
        ctx.arc(0, 0, this.size, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#fff';
        ctx.fillText(this.type === 'fish' ? 'ğŸŸ' : 'ğŸ¥›', 0, 0);
        
        const lifeRatio = this.life / this.maxLife;
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, 0, this.size + 5, -Math.PI/2, -Math.PI/2 + Math.PI*2 * lifeRatio);
        ctx.stroke();
        
        ctx.restore();
    }
    
    isCollected() {
        return this.collected;
    }
    
    applyEffect(cat) {
        if (cat) {
            cat.heal(this.healthAmount);
        }
        if (game) {
            game.showDialog(this.type === 'fish' ? "ğŸŸ åƒåˆ°äº†é±¼å¹²ï¼Œæ¢å¤ç”Ÿå‘½å€¼ï¼" : "ğŸ¥› å–åˆ°äº†ç‰›å¥¶ï¼Œæ¢å¤ç”Ÿå‘½å€¼ï¼");
            game.addScore(10);
            if (game.audioManager) {
                game.audioManager.playHeal();
            }
            if (game.effects) {
                game.effects.itemCollectEffect(this.x, this.y, 'health');
            }
        }
    }
}

// æ”»å‡»é“å…·ç±»
class AttackItem {
    constructor(type, x, y) {
        this.type = type;
        this.x = x;
        this.y = y;
        this.size = 15;
        this.life = 300;
        this.maxLife = 300;
        this.collected = false;
        this.speed = Math.random() * 2 + 1;
        this.direction = Math.random() * Math.PI * 2;
        this.rotation = 0;
        this.rotationSpeed = (Math.random() - 0.5) * 0.1;
        
        this.icons = {
            fish: 'ğŸŸ',
            bone: 'ğŸ¦´',
            mouse: 'ğŸ­',
            ball: 'ğŸ¾'
        };
        
        this.colors = {
            fish: '#4fc3f7',
            bone: '#f0f0f0',
            mouse: '#795548',
            ball: '#ffeb3b'
        };
        
        this.effects = {
            fish: { damage: 50, message: "ğŸŸ å°é±¼å¹²æ”»å‡»ï¼" },
            bone: { damage: 30, message: "ğŸ¦´ éª¨å¤´æ‰“å‡»ï¼" },
            mouse: { damage: 70, message: "ğŸ­ ç©å…·é¼ çªè¢­ï¼" },
            ball: { damage: 40, message: "ğŸ¾ æ¯›çº¿çƒè½°ç‚¸ï¼" }
        };
    }
    
    update() {
        this.life--;
        if (this.life <= 0) {
            this.collected = true;
        }
        
        this.x += Math.cos(this.direction) * this.speed;
        this.y += Math.sin(this.direction) * this.speed;
        this.rotation += this.rotationSpeed;
        
        if (this.x < this.size || this.x > CONFIG.width - this.size) {
            this.direction = Math.PI - this.direction;
        }
        if (this.y < this.size || this.y > CONFIG.height - this.size) {
            this.direction = -this.direction;
        }
    }
    
    draw() {
        if (!ctx) return;
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        
        ctx.fillStyle = this.colors[this.type];
        ctx.beginPath();
        ctx.arc(0, 0, this.size, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#fff';
        ctx.fillText(this.icons[this.type], 0, 0);
        
        const lifeRatio = this.life / this.maxLife;
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, 0, this.size + 5, -Math.PI/2, -Math.PI/2 + Math.PI*2 * lifeRatio);
        ctx.stroke();
        
        ctx.restore();
    }
    
    isCollected() {
        return this.collected;
    }
    
    applyEffect(boss) {
        if (boss) {
            const effect = this.effects[this.type];
            boss.takeDamage(effect.damage);
            if (game) {
                game.showDialog(effect.message);
                game.addScore(20);
                if (game.audioManager) {
                    game.audioManager.playBossHit();
                }
                if (game.effects) {
                    game.effects.showDamageNumber(this.x, this.y, effect.damage, effect.damage > 50);
                }
            }
        }
    }
}

// é›¨æ»´ç±»
class RainDrop {
    constructor() {
        this.x = Math.random() * CONFIG.width;
        this.y = Math.random() * -CONFIG.height;
        this.speed = Math.random() * 10 + 5;
        this.length = Math.random() * 15 + 10;
        this.opacity = Math.random() * 0.5 + 0.3;
    }
    
    update() {
        this.y += this.speed;
        if (this.y > CONFIG.height) {
            this.y = Math.random() * -50;
            this.x = Math.random() * CONFIG.width;
        }
    }
    
    draw() {
        if (!ctx) return;
        ctx.strokeStyle = `rgba(173, 216, 230, ${this.opacity})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x, this.y + this.length);
        ctx.stroke();
    }
}

// é“å…·ç±»
class Item {
    constructor(type, x, y) {
        this.type = type;
        this.x = x;
        this.y = y;
        this.size = 20;
        this.life = 300;
        this.maxLife = 300;
        this.collected = false;
        
        this.icons = {
            energy: 'ğŸ”‹',
            health: 'â¤ï¸',
            speed: 'âš¡',
            shield: 'ğŸ›¡ï¸'
        };
        
        this.colors = {
            energy: '#a8e6cf',
            health: '#ff8fab',
            speed: '#ffcc80',
            shield: '#a9def9'
        };
    }
    
    update() {
        this.life--;
        if (this.life <= 0) {
            this.collected = true;
        }
    }
    
    draw() {
        if (!ctx) return;
        ctx.fillStyle = this.colors[this.type];
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.font = '20px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#fff';
        ctx.fillText(this.icons[this.type], this.x, this.y);
        
        const lifeRatio = this.life / this.maxLife;
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size + 5, -Math.PI/2, -Math.PI/2 + Math.PI*2 * lifeRatio);
        ctx.stroke();
    }
    
    isCollected() {
        return this.collected;
    }
    
    applyEffect(cat, laser, boss) {
        if (!game) return;
        
        switch(this.type) {
            case 'energy':
                if (laser) {
                    laser.energy = Math.min(100, laser.energy + 30);
                }
                game.showDialog("ğŸ”‹ èƒ½é‡æ¢å¤ï¼");
                if (game.audioManager) {
                    game.audioManager.playCollect();
                }
                break;
            case 'health':
                if (cat) {
                    cat.heal(30);
                }
                game.showDialog("â¤ï¸ ç”Ÿå‘½å€¼æ¢å¤ï¼");
                if (game.audioManager) {
                    game.audioManager.playHeal();
                }
                break;
            case 'speed':
                if (cat) {
                    cat.buffs.speed = 2;
                    setTimeout(() => { 
                        if (cat) {
                            cat.buffs.speed = 1; 
                        }
                    }, 5000);
                }
                game.showDialog("âš¡ é€Ÿåº¦æå‡ï¼");
                if (game.audioManager) {
                    game.audioManager.playCollect();
                }
                break;
            case 'shield':
                if (cat) {
                    cat.buffs.invinc = true;
                    setTimeout(() => { 
                        if (cat) {
                            cat.buffs.invinc = false; 
                        }
                    }, 3000);
                }
                game.showDialog("ğŸ›¡ï¸ æ— æ•ŒæŠ¤ç›¾ï¼");
                if (game.audioManager) {
                    game.audioManager.playCollect();
                }
                break;
        }
        if (game.effects) {
            game.effects.itemCollectEffect(this.x, this.y, this.type);
        }
    }
}

// å°ç°å°˜æ€ªç±»
class MiniDustMonster {
    constructor(x, y, color, target) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.target = target;
        this.size = 25;
        this.speed = 2.5;
        this.life = 100;
        this.maxLife = 100;
        this.rotation = Math.random() * Math.PI * 2;
        this.scale = 1;
    }
    
    update() {
        if (!this.target) return;
        
        let dx = this.target.x - this.x;
        let dy = this.target.y - this.y;
        let dist = Math.sqrt(dx*dx + dy*dy);
        
        if (dist > 0) {
            this.x += (dx / dist) * this.speed;
            this.y += (dy / dist) * this.speed;
        }
        
        this.rotation += 0.05;
        this.scale = 0.8 + Math.sin(this.rotation * 3) * 0.2;
        
        this.life--;
    }
    
    draw() {
        if (!ctx) return;
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation * 0.3);
        ctx.scale(this.scale, this.scale);
        
        ctx.beginPath();
        ctx.arc(0, 0, this.size, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.strokeStyle = '#999';
        ctx.lineWidth = 1;
        ctx.stroke();
        
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        for (let i = 0; i < 8; i++) {
            const angle = Math.random() * Math.PI * 2;
            const length = Math.random() * 6 + 3;
            const startX = Math.cos(angle) * this.size;
            const startY = Math.sin(angle) * this.size;
            const endX = startX + Math.cos(angle) * length;
            const endY = startY + Math.sin(angle) * length;
            
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
        }
        
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1.5;
        ctx.lineCap = 'round';
        
        ctx.beginPath();
        ctx.moveTo(-8, -3);
        ctx.lineTo(-3, -3);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(8, -3);
        ctx.lineTo(3, -3);
        ctx.stroke();
        
        ctx.restore();
    }
    
    isAlive() {
        return this.life > 0;
    }
}

// æ¸¸æˆä¸»é€»è¾‘
class Game {
    constructor() {
        this.active = false;
        this.paused = false;
        this.timeScale = 1.0;
        this.particles = [];
        this.clones = [];
        this.miniDustMonsters = [];
        this.items = [];
        this.attackItems = [];
        this.healthItems = [];
        this.rainDrops = [];
        this.raining = false;
        this.rainTimer = 0;
        this.attackItemTimer = 0;
        this.healthItemTimer = 0;
        this.score = 0;
        this.combo = 0;
        this.comboTimer = 0;
        this.startTime = 0;
        this.lastComboEffect = 0;
        this.missions = [
            { id: 1, text: "è§¦å‘æœºå…³ 3 æ¬¡", target: 3, current: 0, done: false },
            { id: 2, text: "è¾¾åˆ° 20 è¿å‡»", target: 20, current: 0, done: false },
            { id: 3, text: "å­˜æ´» 60 ç§’", target: 60, current: 0, done: false },
            { id: 4, text: "å‡»è´¥ 5 ä¸ªå°ç°å°˜æ€ª", target: 5, current: 0, done: false },
            { id: 5, text: "æ”¶é›† 3 ä¸ªé“å…·", target: 3, current: 0, done: false },
            { id: 6, text: "æ”¶é›† 5 ä¸ªæ”»å‡»é“å…·", target: 5, current: 0, done: false },
            { id: 7, text: "ä½¿ç”¨æŠ€èƒ½ 10 æ¬¡", target: 10, current: 0, done: false }
        ];
        
        this.audioManager = null;
        this.achievementSystem = null;
        this.catProgression = null;
        this.effects = null;
        this.laser = null;
        this.cat = null;
        this.boss = null;
        this.interactables = null;
        this.input = { x: 0, y: 0 };
        
        this.loopId = null;
        this.errorCount = 0;
        this.maxErrors = 10;
        
        this.initGame();
    }
    
    initGame() {
        try {
            // åˆå§‹åŒ–ç”»å¸ƒå’Œä¸Šä¸‹æ–‡
            canvas = document.getElementById('gameCanvas');
            if (!canvas) {
                console.error('æ‰¾ä¸åˆ°æ¸¸æˆç”»å¸ƒå…ƒç´ ');
                return;
            }
            
            ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error('æ— æ³•è·å–ç”»å¸ƒä¸Šä¸‹æ–‡');
                return;
            }
            
            // åˆå§‹åŒ–UIå¼•ç”¨
            ui = {
                bossHp: document.getElementById('boss-hp'),
                catHp: document.getElementById('cat-hp'),
                laserEnergy: document.getElementById('laser-energy'),
                score: document.getElementById('score'),
                combo: document.getElementById('combo'),
                phase: document.getElementById('phase-chip'),
                skillCd: document.getElementById('skill-cd'),
                skillBtn: document.getElementById('skill-btn'),
                dialog: document.getElementById('dialog-box'),
                missionList: document.getElementById('mission-list'),
                cursor: document.getElementById('cursor'),
                catLevel: document.getElementById('cat-level')
            };
            
            // åˆå§‹åŒ–ç³»ç»Ÿ
            this.audioManager = new AudioManager();
            this.achievementSystem = new AchievementSystem();
            this.catProgression = new CatProgression();
            this.effects = new AdvancedEffects();
            this.effects.init();
            
            this.resize();
            window.addEventListener('resize', () => this.resize());
            this.setupInput();
            if(!this.bgMusicPlayer)
            {
                this.bgMusicPlayer = new BackgroundMusicPlayer();
            }
            this.bgMusicPlayer.play('./audio/jimi.mp3');
            console.log('æ¸¸æˆåˆå§‹åŒ–å®Œæˆ');
        } catch (error) {
            console.error('æ¸¸æˆåˆå§‹åŒ–å¤±è´¥:', error);
        }
    }

    setupInput() {
        if (!canvas) return;
        
        document.addEventListener('keydown', e => { 
            if(e.code === 'Space') this.triggerSkill(); 
            if(e.code === 'KeyP') this.togglePause();
            if(e.key === '1') SkillSystem.useClone(this.cat);
            if(e.key === '2') SkillSystem.useShield(this.cat);
            if(e.key === '3') SkillSystem.useSlow();
        });

        const updatePos = (clientX, clientY) => {
            if (!canvas || !this.active) return;
            
            const rect = canvas.getBoundingClientRect();
            this.input.x = (clientX - rect.left) * (CONFIG.width / rect.width);
            this.input.y = (clientY - rect.top) * (CONFIG.height / rect.height);
            
            if (ui.cursor) {
                ui.cursor.style.left = clientX + 'px';
                ui.cursor.style.top = clientY + 'px';
            }
            
            if (this.active && !this.paused && this.effects) {
                this.effects.createLaserTrail(this.input.x, this.input.y);
            }
        };

        window.addEventListener('mousemove', e => updatePos(e.clientX, e.clientY));
        window.addEventListener('touchmove', e => {
            e.preventDefault();
            if (e.touches.length > 0) {
                updatePos(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, {passive: false});
    }

    resize() {
        if (!canvas || !ctx) return;
        
        try {
            let scale = Math.min(window.innerWidth / CONFIG.width, window.innerHeight / CONFIG.height) * 0.95;
            canvas.width = CONFIG.width; 
            canvas.height = CONFIG.height;
            canvas.style.width = (CONFIG.width * scale) + 'px';
            canvas.style.height = (CONFIG.height * scale) + 'px';
            this.scale = scale;
            
            const effectsCanvas = document.getElementById('effectsCanvas');
            if (effectsCanvas) {
                effectsCanvas.width = CONFIG.width;
                effectsCanvas.height = CONFIG.height;
            }
        } catch (error) {
            console.error('è°ƒæ•´ç”»å¸ƒå¤§å°å¤±è´¥:', error);
        }
    }

    init(catType) {
        try {
            // åœæ­¢ä¹‹å‰çš„æ¸¸æˆå¾ªç¯
            if (this.loopId) {
                cancelAnimationFrame(this.loopId);
                this.loopId = null;
            }
            
            document.getElementById('start-screen').style.display = 'none';
            document.body.classList.remove('prestart');
            this.active = true;
            this.paused = false;
            this.startTime = Date.now();
            this.catType = catType;
            
            // é‡ç½®çŠ¶æ€
            this.score = 0;
            this.combo = 0;
            this.lastComboEffect = 0;
            this.errorCount = 0;
            
            this.catProgression = new CatProgression();
            this.achievementSystem = new AchievementSystem();
            
            SkillSystem.timer = { clone: 0, shield: 0, slow: 0 };
            SkillSystem.active = { shield: false, slow: false };
            SkillSystem.cloneParticles = [];
            
            this.particles = [];
            this.clones = [];
            this.miniDustMonsters = [];
            this.items = [];
            this.attackItems = [];
            this.healthItems = [];
            this.rainDrops = [];
            this.raining = false;
            
            // åˆ›å»ºæ¸¸æˆå¯¹è±¡
            this.laser = new Laser();
            this.cat = new Cat(catType);
            this.boss = new DustMonster();
            this.interactables = [
                new Interactable('spray', 100, 100, 'ğŸš¿'),
                new Interactable('trap', CONFIG.width-100, CONFIG.height-100, 'ğŸª¤'),
                new Interactable('toy', CONFIG.width/2, 80, 'ğŸ§¶')
            ];
            
            this.spawnItems();
            
            // æ›´æ–°UI
            if (ui.score) ui.score.innerText = this.score;
            if (ui.combo) ui.combo.innerText = this.combo;
            if (ui.catLevel) ui.catLevel.innerText = this.catProgression.level;
            
            SkillSystem.updateSkillUI();
            
            this.updateMissionsUI();
            
            // å¼€å§‹æ¸¸æˆå¾ªç¯
            this.loop();
            
            this.showDialog("ğŸ® æ¸¸æˆå¼€å§‹ï¼ç§»åŠ¨é¼ æ ‡å¼•å¯¼çŒ«å’ªæ”»å‡»ç°å°˜å°æ€ªå…½ï¼");
            
            this.timeScale = 1.0;
            const timeSlowOverlay = document.getElementById('time-slow-overlay');
            if (timeSlowOverlay) {
                timeSlowOverlay.style.opacity = '0';
            }
            
            console.log('æ¸¸æˆå¼€å§‹');
        } catch (error) {
            console.error('æ¸¸æˆåˆå§‹åŒ–å¤±è´¥:', error);
            this.showDialog("æ¸¸æˆåˆå§‹åŒ–å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•");
        }
    }

    loop() {
        try {
            if (!this.active || this.paused || !ctx) {
                this.loopId = requestAnimationFrame(() => this.loop());
                return;
            }
            
            // æ¸…é™¤ç”»å¸ƒ
            ctx.clearRect(0, 0, CONFIG.width, CONFIG.height);
            
            // ç»˜åˆ¶èƒŒæ™¯
            this.drawBackground();
            
            // æ›´æ–°æ¸¸æˆå¯¹è±¡
            if (this.laser) this.laser.update(this.input);
            if (this.cat) this.cat.update(this.laser, this.boss);
            if (this.boss) this.boss.update(this.cat);
            if (this.interactables) {
                this.interactables.forEach(i => i.update(this.laser));
            }
            
            SkillSystem.update();
            
            // æ›´æ–°å½±åˆ†èº«
            for (let i = this.clones.length - 1; i >= 0; i--) {
                if (!this.clones[i].update(this.cat)) {
                    this.clones.splice(i, 1);
                }
            }
            
            // æ›´æ–°å°ç°å°˜æ€ª
            this.miniDustMonsters.forEach((mini, index) => {
                mini.update();
                if (!mini.isAlive()) {
                    this.miniDustMonsters.splice(index, 1);
                    this.checkMission(4, this.missions[3].current + 1);
                    this.addScore(50);
                    this.spawnParticles(mini.x, mini.y, mini.color, 8);
                    
                    if (Math.random() < 0.3) {
                        const itemTypes = ['energy', 'health', 'speed', 'shield'];
                        const randomType = itemTypes[Math.floor(Math.random() * itemTypes.length)];
                        this.items.push(new Item(randomType, mini.x, mini.y));
                    }
                }
            });
            
            // æ›´æ–°é“å…·
            this.items.forEach((item, index) => {
                item.update();
                if (item.isCollected()) {
                    this.items.splice(index, 1);
                } else {
                    const dx = this.cat.x - item.x;
                    const dy = this.cat.y - item.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    
                    if (dist < 30) {
                        item.applyEffect(this.cat, this.laser, this.boss);
                        item.collected = true;
                        this.checkMission(5, this.missions[4].current + 1);
                        this.addScore(50);
                        this.spawnParticles(item.x, item.y, item.colors[item.type], 10);
                    }
                }
            });
            
            // æ›´æ–°æ”»å‡»é“å…·
            this.attackItemTimer++;
            if (this.attackItemTimer > 60 && this.attackItems.length < 5) {
                this.spawnAttackItem();
                this.attackItemTimer = 0;
            }
            
            this.attackItems.forEach((item, index) => {
                item.update();
                if (item.isCollected()) {
                    this.attackItems.splice(index, 1);
                } else {
                    const dx = this.cat.x - item.x;
                    const dy = this.cat.y - item.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    
                    if (dist < 30) {
                        item.applyEffect(this.boss);
                        item.collected = true;
                        this.checkMission(6, this.missions[5].current + 1);
                        this.spawnParticles(item.x, item.y, item.colors[item.type], 10);
                    }
                }
            });
            
            // æ›´æ–°ç”Ÿå‘½é“å…·
            this.healthItemTimer++;
            if (this.healthItemTimer > 120 && this.healthItems.length < 3) {
                this.spawnHealthItem();
                this.healthItemTimer = 0;
            }
            
            this.healthItems.forEach((item, index) => {
                item.update();
                if (item.isCollected()) {
                    this.healthItems.splice(index, 1);
                } else {
                    const dx = this.cat.x - item.x;
                    const dy = this.cat.y - item.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    
                    if (dist < 30) {
                        item.applyEffect(this.cat);
                        item.collected = true;
                        this.spawnParticles(item.x, item.y, item.type === 'fish' ? '#ffcc80' : '#e0f7fa', 10);
                    }
                }
            });
            
            // æ›´æ–°é›¨æ»´
            if (this.raining) {
                this.rainDrops.forEach(drop => drop.update());
                this.rainTimer--;
                if (this.rainTimer <= 0) {
                    this.raining = false;
                    this.rainDrops = [];
                }
            }
            
            // æ›´æ–°ç²’å­
            this.particles.forEach((p, i) => {
                p.update(); 
                p.draw(ctx);
                if(p.life <= 0) this.particles.splice(i, 1);
            });

            // ç»˜åˆ¶æ¸¸æˆå¯¹è±¡
            this.clones.forEach(clone => clone.draw());
            if (this.interactables) this.interactables.forEach(i => i.draw());
            this.items.forEach(item => item.draw());
            this.attackItems.forEach(item => item.draw());
            this.healthItems.forEach(item => item.draw());
            this.miniDustMonsters.forEach(mini => mini.draw());
            if (this.boss) this.boss.draw();
            if (this.cat) this.cat.draw();
            if (this.laser) this.laser.draw();
            
            if (this.raining) {
                this.rainDrops.forEach(drop => drop.draw());
            }

            // æ›´æ–°è¿å‡»è®¡æ—¶å™¨
            if (this.comboTimer > 0) {
                this.comboTimer--;
                if (this.comboTimer <= 0) { 
                    this.combo = 0; 
                    this.updateComboUI(); 
                }
            }
            
            // æ£€æŸ¥ä»»åŠ¡
            let time = Math.floor((Date.now() - this.startTime)/1000);
            this.checkMission(2, this.combo);
            this.checkMission(3, time);
            
            // æ£€æŸ¥æˆå°±
            this.achievementSystem.checkAchievements(this);

            // é‡ç½®é”™è¯¯è®¡æ•°
            this.errorCount = 0;
            
            // ç»§ç»­æ¸¸æˆå¾ªç¯
            this.loopId = requestAnimationFrame(() => this.loop());
        } catch (error) {
            console.error('æ¸¸æˆå¾ªç¯é”™è¯¯:', error);
            this.errorCount++;
            
            // å¦‚æœé”™è¯¯å¤ªå¤šï¼Œåœæ­¢æ¸¸æˆ
            if (this.errorCount >= this.maxErrors) {
                console.error('æ¸¸æˆé”™è¯¯è¿‡å¤šï¼Œåœæ­¢æ¸¸æˆ');
                this.active = false;
                this.showDialog("æ¸¸æˆå‘ç”Ÿé”™è¯¯ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•");
                return;
            }
            
            // ç»§ç»­å°è¯•æ¸¸æˆå¾ªç¯
            this.loopId = requestAnimationFrame(() => this.loop());
        }
    }
    
    spawnClone(x, y, angle) {
        this.clones.push(new CloneCat(x, y, angle));
    }
    
    spawnAttackItem() {
        const itemTypes = ['fish', 'bone', 'mouse', 'ball'];
        const x = Math.random() * (CONFIG.width - 100) + 50;
        const y = Math.random() * (CONFIG.height - 100) + 50;
        const type = itemTypes[Math.floor(Math.random() * itemTypes.length)];
        this.attackItems.push(new AttackItem(type, x, y));
    }
    
    spawnHealthItem() {
        const x = Math.random() * (CONFIG.width - 100) + 50;
        const y = Math.random() * (CONFIG.height - 100) + 50;
        this.healthItems.push(new HealthItem(x, y));
    }
    
    spawnItems() {
        const itemTypes = ['energy', 'health', 'speed', 'shield'];
        for (let i = 0; i < 5; i++) {
            const x = Math.random() * (CONFIG.width - 100) + 50;
            const y = Math.random() * (CONFIG.height - 100) + 50;
            const type = itemTypes[Math.floor(Math.random() * itemTypes.length)];
            this.items.push(new Item(type, x, y));
        }
    }
    
    startRain() {
        this.raining = true;
        this.rainTimer = 180;
        this.rainDrops = [];
        
        for (let i = 0; i < 100; i++) {
            this.rainDrops.push(new RainDrop());
        }
    }
    
    drawBackground() {
        if (!ctx) return;
        
        ctx.fillStyle = '#FFF5F9';
        ctx.fillRect(0, 0, CONFIG.width, CONFIG.height);
        
        const now = Date.now();
        ctx.save();
        
        ctx.fillStyle = 'rgba(255, 182, 193, 0.2)';
        for(let i = 0; i < 15; i++) {
            const t = now / 3000 + i * 0.5;
            const x = (i * 70 + (t*20 % CONFIG.width)) % CONFIG.width;
            const y = (CONFIG.height/2) + Math.sin(t) * 150 + (i%5-2)*50;
            const size = 15 + Math.sin(t*2)*5;
            this.drawHeart(ctx, x, y, size);
        }
        
        ctx.fillStyle = 'rgba(255, 230, 240, 0.6)';
        for(let i = 0; i < 5; i++) {
            const t = now / 5000 + i * Math.PI;
            const x = (CONFIG.width + (t * 50)) % (CONFIG.width + 200) - 100;
            const y = (i * (CONFIG.height / 5)) + Math.sin(t*0.7) * 30;
            this.drawCloud(ctx, x, y, 60 + Math.sin(t)*10);
        }
        ctx.restore();
    }
    
    drawHeart(ctx, x, y, size) {
        ctx.beginPath();
        ctx.moveTo(x, y + size * 0.25);
        ctx.bezierCurveTo(x - size * 0.5, y - size * 0.5, x - size, y, x, y + size);
        ctx.bezierCurveTo(x + size, y, x + size * 0.5, y - size * 0.5, x, y + size * 0.25);
        ctx.fill();
    }
    
    drawCloud(ctx, x, y, width) {
        ctx.beginPath();
        const height = width * 0.6;
        ctx.arc(x, y, width * 0.3, Math.PI * 0.5, Math.PI * 1.5);
        ctx.arc(x + width * 0.4, y - height * 0.3, width * 0.4, Math.PI, Math.PI * 1.8);
        ctx.arc(x + width, y, width * 0.3, Math.PI * 1.5, Math.PI * 0.5);
        ctx.closePath();
        ctx.fill();
    }

    addScore(val) {
        if (!val || isNaN(val)) return;
        
        this.score += val * (1 + this.combo * 0.1);
        if (ui.score) {
            ui.score.innerText = Math.floor(this.score);
        }
        
        if (this.catProgression) {
            this.catProgression.addExperience(val);
        }
        
        if (val > 50 && this.cat && this.effects) {
            this.effects.showDamageNumber(
                this.cat.x, 
                this.cat.y - 30, 
                val, 
                val > 100
            );
        }
    }

    updateComboUI() {
        if (ui.combo) {
            ui.combo.innerText = this.combo;
            if (ui.combo.parentElement) {
                ui.combo.parentElement.style.transform = this.combo > 0 ? 'scale(1.2)' : 'scale(1)';
                ui.combo.parentElement.style.transition = 'transform 0.2s cubic-bezier(0.18, 0.89, 0.32, 1.28)';
            }
        }
        
        if (this.combo > 0 && this.combo % 5 === 0 && this.combo !== this.lastComboEffect) {
            if (this.effects) {
                this.effects.comboEffect(this.combo);
            }
            this.lastComboEffect = this.combo;
            
            if (this.combo >= 10 && this.effects) {
                this.effects.screenShake(Math.min(3, this.combo / 10), 300);
            }
        }
    }

    checkMission(id, val) {
        let m = this.missions.find(m => m.id === id);
        if (m && !m.done) {
            m.current = Math.min(val, m.target);
            if (m.current >= m.target) {
                m.done = true;
                this.showDialog(`ğŸ† ä»»åŠ¡å®Œæˆï¼š${m.text}`);
                this.addScore(500);
            }
            this.updateMissionsUI();
        }
    }

    updateMissionsUI() {
        if (!ui.missionList) return;
        
        ui.missionList.innerHTML = this.missions.map(m => `
            <li class="mission-item ${m.done ? 'complete' : ''}">
                ${m.done ? 'âœ…' : 'â¬œ'} ${m.text} 
                <span style="float:right; font-weight: bold;">${m.current}/${m.target}</span>
            </li>
        `).join('');
    }

    triggerSkill() { 
        if(this.active && this.cat && !this.paused) {
            this.cat.useSkill();
            if (this.effects) {
                this.effects.skillEffect(this.cat.stats.skill, this.cat.x, this.cat.y);
            }
        }
    }

    showDialog(text) {
        if (!ui.dialog) return;
        
        ui.dialog.innerText = text;
        ui.dialog.style.display = 'block';
        ui.dialog.style.animation = 'none';
        ui.dialog.offsetHeight; 
        ui.dialog.style.animation = 'popIn 0.4s cubic-bezier(0.18, 0.89, 0.32, 1.28)';
        if(this.msgTimer) clearTimeout(this.msgTimer);
        this.msgTimer = setTimeout(() => {
            if (ui.dialog) {
                ui.dialog.style.display = 'none';
            }
        }, 3000);
    }

    spawnParticles(x, y, color, count) {
        for(let i=0; i<count; i++) this.particles.push(new Particle(x, y, color, 5, 40));
    }
    
    spawnMiniDustMonsters(count, x, y, color) {
        for (let i = 0; i < count; i++) {
            const angle = (i / count) * Math.PI * 2;
            const spawnX = x + Math.cos(angle) * 30;
            const spawnY = y + Math.sin(angle) * 30;
            this.miniDustMonsters.push(new MiniDustMonster(spawnX, spawnY, color, this.cat));
        }
    }

    togglePause() {
        if (!this.active) return;
        
        this.paused = !this.paused;
        const pauseScreen = document.getElementById('pause-screen');
        
        if (this.paused) {
            if (pauseScreen) pauseScreen.style.display = 'flex';
        } else {
            if (pauseScreen) pauseScreen.style.display = 'none';
        }
    }
    
    restart() {
        const pauseScreen = document.getElementById('pause-screen');
        const endScreen = document.getElementById('end-screen');
        
        if (pauseScreen) pauseScreen.style.display = 'none';
        if (endScreen) endScreen.style.display = 'none';
        
        this.active = false;
        
        setTimeout(() => {
            this.init(this.catType || 'tao');
        }, 500);
    }
    
    returnToMainMenu() {
        const pauseScreen = document.getElementById('pause-screen');
        const endScreen = document.getElementById('end-screen');
        
        if (pauseScreen) pauseScreen.style.display = 'none';
        if (endScreen) endScreen.style.display = 'none';
        
        this.active = false;
        
        const startScreen = document.getElementById('start-screen');
        if (startScreen) {
            startScreen.style.display = 'flex';
        }
        document.body.classList.add('prestart');
    }
    
    showAchievements() {
        if (this.achievementSystem) {
            this.achievementSystem.showAchievementsScreen();
        }
    }

    end(win) {
        this.active = false;
        const endScreen = document.getElementById('end-screen');
        if (endScreen) {
            endScreen.style.display = 'flex';
            endScreen.style.animation = 'none';
            endScreen.offsetHeight;
            endScreen.style.animation = 'fadeIn 0.5s ease-out';
            
            const endTitle = document.getElementById('end-title');
            const endDesc = document.getElementById('end-desc');
            const resScore = document.getElementById('res-score');
            const resTime = document.getElementById('res-time');
            const resLevel = document.getElementById('res-level');
            
            if (endTitle) endTitle.innerText = win ? "ğŸ‰ å®Œç¾èƒœåˆ©ï¼" : "ğŸ’” æŒ‘æˆ˜å¤±è´¥";
            if (endDesc) endDesc.innerText = win ? "å®¶é‡Œçš„å’Œå¹³ç”±ä½ å®ˆæŠ¤ï¼" : "åˆ«ç°å¿ƒï¼Œå†æ¥ä¸€æ¬¡ï¼";
            if (resScore) resScore.innerText = Math.floor(this.score);
            if (resTime) resTime.innerText = Math.floor((Date.now() - this.startTime)/1000) + 's';
            if (resLevel) resLevel.innerText = this.catProgression ? this.catProgression.level : 1;
        }
        
        if (win) {
            if (this.audioManager) this.audioManager.playLevelUp();
        } else {
            if (this.audioManager) this.audioManager.playGameOver();
        }
        
        if (win && this.effects) {
            this.effects.screenShake(8, 1000);
            setTimeout(() => this.effects.lightningFlash(), 200);
            setTimeout(() => this.effects.lightningFlash(), 400);
            setTimeout(() => this.effects.lightningFlash(), 600);
        }
    }
}

class Laser {
    constructor() {
        this.x = CONFIG.width/2; 
        this.y = CONFIG.height/2;
        this.energy = 100; 
        this.recovering = false;
        this.lowEnergy = false;
        this.lastTrailTime = 0;
    }
    
    update(input) {
        if (!input) return;
        
        this.x = input.x; 
        this.y = input.y;
        
        if (this.recovering) {
            this.energy += 1.2 * game.timeScale;
            if (this.energy >= 100) { 
                this.recovering = false; 
                this.energy = 100; 
                if (game) {
                    game.showDialog("ğŸ”‹ èƒ½é‡å·²å®Œå…¨æ¢å¤ï¼"); 
                }
            }
        } else {
            this.energy -= 0.08 * game.timeScale;
            
            if (this.energy <= 30 && !this.lowEnergy) {
                this.lowEnergy = true;
                if (game) {
                    game.showDialog("âš ï¸ æ¿€å…‰èƒ½é‡åä½ï¼");
                }
            }
            
            if (this.energy > 40) {
                this.lowEnergy = false;
            }
            
            if (this.energy <= 0) { 
                this.recovering = true; 
                this.lowEnergy = false;
                if (game) {
                    game.showDialog("ğŸ”‹ æ¿€å…‰è¿‡çƒ­ï¼æ­£åœ¨æ¢å¤..."); 
                }
            }
        }
        
        if (ui && ui.laserEnergy) {
            ui.laserEnergy.style.width = this.energy + '%';
            
            if (this.recovering) {
                ui.laserEnergy.style.background = 'linear-gradient(90deg, #ccc, #aaa)';
            } else if (this.lowEnergy) {
                ui.laserEnergy.style.background = 'linear-gradient(90deg, #ffcc80, #ff9800)';
            } else {
                ui.laserEnergy.style.background = 'linear-gradient(90deg, #c5a9ff, #fbc2eb)';
            }
        }
    }
    
    draw() {
        if (!ctx) return;
        
        if (this.recovering) {
            if (Math.floor(Date.now() / 200) % 2 === 0) return;
        }
        
        if (this.lowEnergy) {
            ctx.shadowBlur = 10; 
            ctx.shadowColor = "#ff9800";
            ctx.fillStyle = "#ff9800";
            ctx.beginPath(); 
            ctx.arc(this.x, this.y, 5, 0, Math.PI*2); 
            ctx.fill();
            ctx.fillStyle = "#fff";
            ctx.beginPath(); 
            ctx.arc(this.x, this.y, 2, 0, Math.PI*2); 
            ctx.fill();
        } else {
            ctx.shadowBlur = 20; 
            ctx.shadowColor = "#ff8fab";
            ctx.fillStyle = "#ff8fab";
            ctx.beginPath(); 
            ctx.arc(this.x, this.y, 8, 0, Math.PI*2); 
            ctx.fill();
            ctx.fillStyle = "#fff";
            ctx.beginPath(); 
            ctx.arc(this.x, this.y, 4, 0, Math.PI*2); 
            ctx.fill();
        }
        ctx.shadowBlur = 0;
    }
}

class Cat {
    constructor(type) {
        this.type = type;
        this.x = 100; 
        this.y = CONFIG.height / 2; 
        this.angle = 0;
        this.stats = {
            tao: { speed: 5.5, color: '#ffcc80', skill: 'dash', cd: 500 },
            guai: { speed: 3.5, color: '#a9def9', skill: 'shield', cd: 800 },
            qi: { speed: 4.5, color: '#e4c1f9', skill: 'weakness', cd: 600 }
        }[type] || { speed: 4.5, color: '#ffcc80', skill: 'dash', cd: 500 };
        
        this.cd = 0; 
        this.state = 'IDLE';
        this.buffs = { speed: 1, invinc: false, heal: false };
        
        this.maxHp = 100;
        this.hp = this.maxHp;
        this.hurtCooldown = 0;
        this.hurtCooldownMax = 60;
        
        this.shieldHp = 0;
        this.shieldMaxHp = 0;
        
        if (ui && document.getElementById('skill-icon')) {
            document.getElementById('skill-icon').innerText = {'tao':'âš¡','guai':'ğŸ›¡ï¸','qi':'ğŸ”'}[type] || 'ğŸ¾';
        }
    }
    
    heal(amount) {
        if (!amount || isNaN(amount)) return;
        
        this.hp = Math.min(this.maxHp, this.hp + amount);
        this.updateHpUI();
        if (game) {
            game.spawnParticles(this.x, this.y, '#a8e6cf', 10);
        }
    }
    
    takeDamage(amount) {
        if (!amount || isNaN(amount)) return;
        
        if (this.shieldHp > 0) {
            this.shieldHp -= amount;
            amount = Math.max(0, amount - this.shieldHp);
            if (this.shieldHp <= 0) {
                SkillSystem.active.shield = false;
                this.buffs.invinc = false;
                if (game) {
                    game.showDialog("ğŸ›¡ï¸ æŠ¤ç›¾ç ´ç¢ï¼");
                }
            }
        }
        
        if (this.hurtCooldown > 0 || this.buffs.invinc) return;
        
        if (amount > 0) {
            this.hp = Math.max(0, this.hp - amount);
            this.hurtCooldown = this.hurtCooldownMax;
            this.updateHpUI();
            
            if (game) {
                game.spawnParticles(this.x, this.y, '#ff8fab', 10);
                if (game.audioManager) {
                    game.audioManager.playHit();
                }
                if (game.effects) {
                    game.effects.hitFlash();
                    game.effects.screenShake(3, 200);
                }
                
                if (this.hp <= 0) {
                    game.end(false);
                    game.showDialog("ğŸ˜¿ çŒ«å’ªå—ä¼¤è¿‡é‡ï¼Œæ¸¸æˆç»“æŸï¼");
                }
            }
        }
    }
    
    updateHpUI() {
        if (ui && ui.catHp) {
            ui.catHp.style.width = (this.hp / this.maxHp * 100) + '%';
        }
    }
    
    update(laser, boss) {
        if (this.hurtCooldown > 0) {
            this.hurtCooldown--;
        }
        
        if (this.cd > 0) {
            this.cd--;
            if (ui && ui.skillCd) {
                ui.skillCd.style.transform = `scaleY(${this.cd/this.stats.cd})`;
            }
            if (ui && ui.skillBtn && !ui.skillBtn.classList.contains('cooldown')) {
                ui.skillBtn.classList.add('cooldown');
            }
        } else {
            if (ui && ui.skillCd) {
                ui.skillCd.style.transform = 'scaleY(0)';
            }
            if (ui && ui.skillBtn) {
                ui.skillBtn.classList.remove('cooldown');
            }
        }

        if(this.buffs.heal && game) {
             game.spawnParticles(this.x, this.y, '#a8e6cf', 1);
        }

        if (!laser) return;
        
        let dx = laser.x - this.x;
        let dy = laser.y - this.y;
        let dist = Math.sqrt(dx*dx + dy*dy);
        if (dist > 15 && !this.buffs.heal) {
            this.angle = Math.atan2(dy, dx);
            let spd = this.stats.speed * this.buffs.speed;
            if (game && game.catProgression) {
                spd *= game.catProgression.getSpeedMultiplier();
            }
            if (game) {
                spd *= game.timeScale;
            }
            this.x += Math.cos(this.angle) * spd;
            this.y += Math.sin(this.angle) * spd;
        }

        if (game && game.miniDustMonsters) {
            game.miniDustMonsters.forEach((mini, index) => {
                let dx = this.x - mini.x;
                let dy = this.y - mini.y;
                if (Math.sqrt(dx*dx + dy*dy) < 30) {
                    this.takeDamage(10);
                    game.miniDustMonsters.splice(index, 1);
                    if (game) {
                        game.showDialog("ğŸ˜¿ è¢«å°ç°å°˜æ€ªæ’åˆ°äº†ï¼");
                        game.combo = 0; 
                        game.updateComboUI();
                    }
                }
            });
        }

        if (boss) {
            let dx_boss = this.x - boss.x;
            let dy_boss = this.y - boss.y;
            if (Math.sqrt(dx_boss*dx_boss + dy_boss*dy_boss) < 60) {
                this.takeDamage(15);
                this.x += Math.cos(Math.atan2(dy_boss, dx_boss)) * 60;
                this.y += Math.sin(Math.atan2(dy_boss, dx_boss)) * 60;
                if (game) {
                    game.showDialog("ğŸ˜¿ å“å“Ÿï¼è¢«æ’åˆ°äº†ï¼");
                    game.combo = 0; 
                    game.updateComboUI();
                }
            }
        }
        
        this.x = Math.max(30, Math.min(CONFIG.width-30, this.x));
        this.y = Math.max(30, Math.min(CONFIG.height-30, this.y));
    }
    
    useSkill() {
        if (this.cd > 0 || !game) return;
        this.cd = this.stats.cd;
        game.showDialog("âœ¨ é‡Šæ”¾å¤§æ‹›ï¼");
        if (game.audioManager) {
            game.audioManager.playSkill();
        }
        
        if (this.stats.skill === 'dash') {
            this.buffs.speed = 3; 
            this.buffs.invinc = true;
            setTimeout(() => { 
                this.buffs.speed = 1; 
                this.buffs.invinc = false; 
            }, 2000);
        } else if (this.stats.skill === 'shield') {
            this.buffs.invinc = true; 
            this.buffs.heal = true;
            setTimeout(() => { 
                this.buffs.invinc = false; 
                this.buffs.heal = false; 
            }, 4000);
        } else if (this.stats.skill === 'weakness') {
            if (game.boss) {
                game.boss.weaknessRevealed = true;
            }
            if (game.interactables) {
                game.interactables.forEach(i => i.progress = 100);
            }
            setTimeout(() => { 
                if (game.boss) {
                    game.boss.weaknessRevealed = false; 
                }
            }, 5000);
        }
    }
    
    draw() {
  if (!ctx) return;
  ctx.save();
  ctx.translate(this.x, this.y);
  ctx.rotate(this.angle);

  // ç¼©æ”¾ï¼ˆä¿æŒä¸åŸé€»è¾‘ä¸€è‡´ï¼‰
  const scale = 1.2;
  ctx.scale(scale, scale);

  // è·å–å½“å‰çŒ«å’ªç±»å‹å¯¹åº”çš„å›¾ç‰‡
  const img = catImages[this.type] || null;

  if (img && img.complete) {
    // åœ†å½¢è£å‰ª
    const size = 24; // åŠå¾„ï¼ˆåŸæ¤­åœ† body æ˜¯ 20x16ï¼Œè¿™é‡Œç•¥å¤§ä¸€ç‚¹ï¼‰
    ctx.beginPath();
    ctx.arc(0, 0, size, 0, Math.PI * 2);
    ctx.closePath();
    ctx.clip(); // è£å‰ªåŒºåŸŸ

    // ç»˜åˆ¶å›¾ç‰‡ï¼ˆå±…ä¸­ï¼‰
    const imgSize = size * 2;
    ctx.drawImage(img, -size, -size, imgSize, imgSize);
  } else {
    // å›é€€åˆ°åŸç»˜åˆ¶é€»è¾‘ï¼ˆå…¼å®¹æ€§ï¼‰
    ctx.fillStyle = this.stats.color;
    ctx.beginPath();
    ctx.ellipse(0, 0, 20, 16, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#DDDDDD';
    ctx.lineWidth = 2;
    ctx.stroke();
    // ï¼ˆæ­¤å¤„å¯ä¿ç•™åŸæœ‰è€³æœµã€çœ¼ç›ç­‰ç»†èŠ‚ï¼Œæˆ–ç®€åŒ–ï¼‰
  }

  // ç»˜åˆ¶è¡€æ¡ã€æŠ¤ç›¾ç­‰ UIï¼ˆä¿æŒä¸å˜ï¼‰
  if (this.shieldHp > 0) {
    const shieldRatio = this.shieldHp / this.shieldMaxHp;
    ctx.beginPath();
    ctx.arc(0, 0, 35, 0, Math.PI * 2);
    ctx.strokeStyle = shieldRatio > 0.5 ? 'rgba(79, 195, 247, 0.8)' :
                     shieldRatio > 0.2 ? 'rgba(255, 152, 0, 0.8)' :
                     'rgba(255, 87, 34, 0.8)';
    ctx.lineWidth = 5;
    ctx.setLineDash([15, 10]);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
    ctx.fillRect(-25, -55, 50, 6);
    ctx.fillStyle = shieldRatio > 0.5 ? '#4fc3f7' :
                   shieldRatio > 0.2 ? '#ff9800' : '#ff5722';
    ctx.fillRect(-25, -55, 50 * shieldRatio, 6);
  }

  if (this.hp < this.maxHp) {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
    ctx.fillRect(-25, -45, 50, 6);
    ctx.fillStyle = this.hp > 50 ? '#a8e6cf' : (this.hp > 20 ? '#ffcc80' : '#ff8fab');
    ctx.fillRect(-25, -45, 50 * (this.hp / this.maxHp), 6);
  }

  if (this.buffs.invinc && !SkillSystem.active.shield) {
    ctx.beginPath();
    ctx.arc(0, 0, 35, 0, Math.PI * 2);
    ctx.strokeStyle = this.buffs.heal ? "rgba(168, 230, 207, 0.8)" : "rgba(255, 223, 0, 0.8)";
    ctx.lineWidth = 5;
    ctx.setLineDash([15, 10]);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  ctx.restore();
}
}
// ===============================
//     èƒŒæ™¯éŸ³ä¹æ’­æ”¾å™¨ï¼ˆå®Œå…¨è§£è€¦ï¼‰
// ===============================
class BackgroundMusicPlayer {
    constructor() {
        this.audio = null;
        this.volume = 0.4; // é»˜è®¤ BGM éŸ³é‡ç¨ä½äºéŸ³æ•ˆ
        this.enabled = true;
        this.currentTrack = null;
        this.loop = true;

        // å¦‚æœé¡µé¢æœ‰ä¸»éŸ³é‡æ»‘å—ï¼Œå¯é€‰ç›‘å¬ï¼ˆéå¿…é¡»ï¼‰
        this.bindGlobalVolume();
    }

    // å¯é€‰ï¼šç›‘å¬å…¨å±€éŸ³é‡ï¼ˆå¦‚æœå¸Œæœ› BGM éšä¸»éŸ³é‡å˜åŒ–ï¼‰
    bindGlobalVolume() {
        const volumeSlider = document.getElementById('volume-slider');
        const pauseVolumeSlider = document.getElementById('pause-volume-slider');
        if (volumeSlider) {
            volumeSlider.addEventListener('input', (e) => {
                const masterVol = e.target.value / 100;
                this.setVolume(masterVol * 0.6); // BGM ç•¥ä½äºä¸»éŸ³æ•ˆ
            });
        }
        if (pauseVolumeSlider) {
            pauseVolumeSlider.addEventListener('input', (e) => {
                const masterVol = e.target.value / 100;
                this.setVolume(masterVol * 0.6);
            });
        }
    }

    // åŠ è½½å¹¶æ’­æ”¾èƒŒæ™¯éŸ³ä¹ï¼ˆURL ä¸ºç›¸å¯¹æˆ–ç»å¯¹è·¯å¾„ï¼‰
    play(trackUrl) {
        if (this.currentTrack === trackUrl && this.audio && !this.audio.paused) {
            return; // å·²åœ¨æ’­æ”¾
        }

        if (this.audio) {
            this.audio.pause();
            this.audio.src = '';
        }

        this.audio = new Audio(trackUrl);
        this.audio.loop = this.loop;
        this.audio.volume = this.volume;
        this.audio.preload = 'auto';

        // é™éŸ³å¤„ç†ï¼ˆå¦‚ Safari è‡ªåŠ¨æ’­æ”¾ç­–ç•¥ï¼‰
        this.audio.muted = true;

        // å°è¯•è‡ªåŠ¨æ’­æ”¾ï¼ˆé¦–æ¬¡éœ€ç”¨æˆ·äº¤äº’ï¼‰
        this.audio.play().catch(() => {
            // é¦–æ¬¡æ’­æ”¾å¤±è´¥æ˜¯æ­£å¸¸çš„ï¼ˆæµè§ˆå™¨ç­–ç•¥ï¼‰ï¼Œåç»­å¯æ‰‹åŠ¨è§¦å‘
            console.log('BGM è‡ªåŠ¨æ’­æ”¾è¢«é˜»æ­¢ï¼ˆéœ€ç”¨æˆ·äº¤äº’åæ’­æ”¾ï¼‰');
        });

        this.currentTrack = trackUrl;

        // ä¸€æ—¦ç”¨æˆ·äº¤äº’ï¼Œå–æ¶ˆé™éŸ³
        const unmute = () => {
            console.log('å–æ¶ˆé™éŸ³');
            if (this.audio) {
                console.log('å¼€å§‹æ’­æ”¾èƒŒæ™¯éŸ³ä¹');
                this.audio.muted = false;
                this.audio.play().catch(e => console.warn('BGM æ’­æ”¾å¤±è´¥:', e));
                document.removeEventListener('click', unmute);
                document.removeEventListener('touchstart', unmute);
            }
        };
        document.addEventListener('click', unmute, { once: true });
        document.addEventListener('touchstart', unmute, { once: true });
    }

    pause() {
        if (this.audio) this.audio.pause();
    }

    resume() {
        if (this.audio && this.audio.paused) {
            this.audio.play().catch(e => console.log('BGM æ¢å¤æ’­æ”¾å¤±è´¥:', e));
        }
    }

    stop() {
        if (this.audio) {
            this.audio.pause();
            this.audio.currentTime = 0;
            this.currentTrack = null;
        }
    }

    setVolume(vol) {
        this.volume = Math.max(0, Math.min(1, vol));
        if (this.audio) this.audio.volume = this.volume;
    }

    isPlaying() {
        return this.audio && !this.audio.paused;
    }
}

class DustMonster {
    constructor() {
        this.x = CONFIG.width - 150; 
        this.y = CONFIG.height/2;
        this.hp = 1000; 
        this.maxHp = 1000;
        this.phase = 1;
        this.weaknessRevealed = false;
        this.attackTimer = 0;
        this.splitTimer = 0;
        this.vx = 0; 
        this.vy = 0;
        this.color = '#D3D3D3';
        this.rotation = 0;
        this.scale = 1;
    }
    
    update(cat) {
        if (!cat) return;
        
        const speedLimit = this.phase * 1.0 * (game ? game.timeScale : 1);
        let dx = cat.x - this.x;
        let dy = cat.y - this.y;
        let dist = Math.sqrt(dx*dx + dy*dy);
        if (dist > 0) {
            this.vx += (dx / dist) * 0.1 * (game ? game.timeScale : 1);
            this.vy += (dy / dist) * 0.1 * (game ? game.timeScale : 1);
        }
        let currentSpeed = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
        if (currentSpeed > speedLimit) {
            this.vx = (this.vx / currentSpeed) * speedLimit;
            this.vy = (this.vy / currentSpeed) * speedLimit;
        }
        this.x += this.vx; 
        this.y += this.vy;
        
        this.attackTimer += (game ? game.timeScale : 1);
        this.splitTimer += (game ? game.timeScale : 1);
        
        let splitChance = 0;
        if (this.phase === 1) splitChance = 0.001;
        else if (this.phase === 2) splitChance = 0.003;
        else splitChance = 0.005;
        
        if (this.splitTimer > 60 && Math.random() < splitChance) {
            this.split();
            this.splitTimer = 0;
        }
        
        if (this.attackTimer > 150) {
            this.attackTimer = 0;
            if (Math.random() < 0.3 * this.phase) this.specialAttack();
        }
        
        if (this.hp < 300 && this.phase < 3) {
            this.phase = 3; 
            if (ui && ui.phase) {
                ui.phase.innerText = "é˜¶æ®µ 3 Â· ç‹‚æš´";
                ui.phase.style.background = "linear-gradient(135deg, #ff5252, #b71c1c)";
            }
            if (game) {
                game.showDialog("ğŸ‘¹ ç°å°˜å°æ€ªå…½ç‹‚æš´äº†ï¼å°å¿ƒåˆ†èº«ï¼");
                if (game.effects) {
                    game.effects.bossPhaseTransition(this.phase);
                }
            }
        } else if (this.hp < 600 && this.phase < 2) {
            this.phase = 2; 
            if (ui && ui.phase) {
                ui.phase.innerText = "é˜¶æ®µ 2 Â· æ„¤æ€’";
            }
            if (game) {
                game.showDialog("ğŸ’¢ ç°å°˜å°æ€ªå…½ç”Ÿæ°”äº†ï¼å¼€å§‹åˆ†èº«ï¼");
                if (game.effects) {
                    game.effects.bossPhaseTransition(this.phase);
                }
            }
        }
        
        this.rotation += 0.02 * (game ? game.timeScale : 1);
        this.scale = 1 + Math.sin(this.rotation * 2) * 0.05;
    }
    
    split() {
        const miniCount = 2 + this.phase;
        const colors = ['#D3D3D3', '#C0C0C0', '#A9A9A9', '#FFB6C1', '#B5EAD7'];
        const color = colors[Math.floor(Math.random() * colors.length)];
        
        if (game) {
            game.spawnMiniDustMonsters(miniCount, this.x, this.y, color);
            game.showDialog("ğŸŒ€ ç°å°˜å°æ€ªå…½åˆ†è£‚äº†ï¼å°å¿ƒå°ç°å°˜æ€ªï¼");
            game.spawnParticles(this.x, this.y, color, 15);
            if (game.effects) {
                game.effects.screenShake(5, 500);
            }
        }
    }
    
    specialAttack() {
        if (!game) return;
        
        game.showDialog("ğŸ’¥ ç°å°˜å°æ€ªå…½å‘åŠ¨æ”»å‡»ï¼");
        for(let i = 0; i < 6 + this.phase * 2; i++) {
            const angle = Math.random() * Math.PI * 2;
            const p = new Particle(this.x, this.y, '#7b2cbf', 0, 120);
            p.vx = Math.cos(angle) * 4 * (game.timeScale || 1); 
            p.vy = Math.sin(angle) * 4 * (game.timeScale || 1);
            p.color = '#7b2cbf';
            p.draw = function(ctx) {
                 if (!ctx) return;
                 ctx.globalAlpha = this.life / this.maxLife;
                 ctx.fillStyle = this.color;
                 ctx.save();
                 ctx.translate(this.x, this.y);
                 ctx.rotate(Math.atan2(this.vy, this.vx));
                 ctx.beginPath();
                 ctx.moveTo(-this.size, -this.size/2);
                 ctx.lineTo(this.size, 0);
                 ctx.lineTo(-this.size, this.size/2);
                 ctx.closePath();
                 ctx.fill();
                 ctx.restore();
                 ctx.globalAlpha = 1;
            };
            game.particles.push(p);
        }
        if (game.effects) {
            game.effects.screenShake(7, 400);
        }
    }
    
    takeDamage(val) {
        if (!val || isNaN(val)) return;
        
        if (this.weaknessRevealed) val *= 2.5;
        this.hp -= val;
        if (ui && ui.bossHp) {
            ui.bossHp.style.width = Math.max(0, (this.hp/this.maxHp*100)) + '%';
        }
        if (game) {
            game.addScore(val);
            game.spawnParticles(this.x + (Math.random()-0.5)*40, this.y + (Math.random()-0.5)*40, '#ffc8dd', 3);
            if (game.audioManager) {
                game.audioManager.playBossHit();
            }
            if (game.effects) {
                const isCritical = this.weaknessRevealed && val > 100;
                game.effects.showDamageNumber(this.x, this.y, val, isCritical);
                
                if (val > 50) {
                    game.effects.screenShake(Math.min(5, val/50), 200);
                }
            }
            
            if (this.hp <= 0) game.end(true);
        }
    }
    
    draw() {
        if (!ctx) return;
        
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation * 0.5);
        ctx.scale(this.scale, this.scale);
        
        this.drawBody();
        this.drawFace();
        
        if (this.weaknessRevealed) {
            ctx.strokeStyle = "#ffeb3b"; 
            ctx.lineWidth = 4;
            ctx.beginPath(); 
            ctx.arc(0, 0, 70, 0, Math.PI*2); 
            ctx.stroke();
            ctx.fillStyle = "#ffeb3b"; 
            ctx.font = "bold 20px 'Fredoka One'"; 
            ctx.textAlign="center"; 
            ctx.fillText("WEAK!", 0, -75);
        }
        ctx.restore();
    }
    
    drawBody() {
        const mainColor = this.color;
        
        ctx.beginPath();
        ctx.arc(0, 0, 50, 0, Math.PI * 2);
        ctx.fillStyle = mainColor;
        ctx.fill();
        ctx.strokeStyle = '#999';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        ctx.strokeStyle = mainColor;
        ctx.lineWidth = 3;
        for (let i = 0; i < 15; i++) {
            const angle = Math.random() * Math.PI * 2;
            const length = Math.random() * 8 + 5;
            const startX = Math.cos(angle) * 50;
            const startY = Math.sin(angle) * 50;
            const endX = startX + Math.cos(angle) * length;
            const endY = startY + Math.sin(angle) * length;
            
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
        }
    }
    
    drawFace() {
        this.drawLineEye(-15, 5);
        this.drawLineEye(15, 5);
        
        ctx.beginPath();
        ctx.arc(-25, 10, 6, 0, Math.PI * 2);
        ctx.arc(25, 10, 6, 0, Math.PI * 2);
        ctx.fillStyle = '#FFB6C1';
        ctx.fill();
    }
    
    drawLineEye(x, y) {
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(x - 5, y);
        ctx.lineTo(x + 5, y);
        ctx.stroke();
    }
}

class Interactable {
    constructor(type, x, y, icon) {
        this.type = type; 
        this.x = x; 
        this.y = y; 
        this.icon = icon;
        this.progress = 0;
    }
    update(laser) {
        if (!laser) return;
        
        if (laser.x > this.x-30 && laser.x < this.x+30 && laser.y > this.y-30 && laser.y < this.y+30) {
            this.progress += 2 * (game ? game.timeScale : 1);
            if (this.progress >= 100) {
                this.progress = 0; 
                this.trigger();
            }
        } else {
            this.progress = Math.max(0, this.progress - 1 * (game ? game.timeScale : 1));
        }
    }
    trigger() {
        if (!game) return;
        
        game.checkMission(1, game.missions[0].current + 1);
        game.spawnParticles(this.x, this.y, '#a8e6cf', 20);
        if (this.type === 'spray') {
            if (game.boss) {
                game.boss.takeDamage(150);
            }
            game.showDialog("ğŸ’¦ å–·é›¾æ”»å‡»ï¼ç°å°˜å°æ€ªå…½å—åˆ°é‡åˆ›ï¼");
            game.startRain();
            if (game.effects) {
                game.effects.screenShake(8, 600);
                game.effects.lightningFlash();
            }
        } else if (this.type === 'trap') {
            if (game.boss) {
                game.boss.vx = 0; 
                game.boss.vy = 0;
            }
            game.showDialog("ğŸª¤ é™·é˜±è§¦å‘ï¼ç°å°˜å°æ€ªå…½è¢«å®šä½äº†ï¼");
            if (game.effects) {
                game.effects.screenShake(5, 400);
            }
        } else {
            game.addScore(200);
            game.showDialog("ğŸ§¶ æ‰¾åˆ°ç©å…·ï¼è·å¾—åˆ†æ•°å¥–åŠ±ï¼");
        }
    }
    draw() {
        if (!ctx) return;
        
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.globalAlpha = 0.8;
        ctx.beginPath(); 
        ctx.arc(0,0,35,0,Math.PI*2);
        ctx.strokeStyle = "#e1d4ff"; 
        ctx.lineWidth = 6; 
        ctx.stroke();
        if(this.progress > 0) {
            ctx.beginPath(); 
            ctx.arc(0,0,35,-Math.PI/2, -Math.PI/2 + Math.PI*2 * (this.progress/100));
            ctx.strokeStyle = "#a8e6cf"; 
            ctx.stroke();
        }
        
        ctx.font = "40px Arial"; 
        ctx.textAlign = "center"; 
        ctx.textBaseline = "middle";
        ctx.fillText(this.icon, 0, 0);
        ctx.restore();
    }
}

// ========== ç™»å½•/æ³¨å†Œé€»è¾‘ ==========
document.addEventListener('DOMContentLoaded', () => {
  const authScreen = document.getElementById('auth-screen');
  const loginForm = document.getElementById('login-form');
  const registerForm = document.getElementById('register-form');
  const tabs = document.querySelectorAll('.auth-tab');
  const messageEl = document.getElementById('auth-message');

  // åˆ‡æ¢ç™»å½•/æ³¨å†Œ
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      tab.classList.add('active');
      const target = tab.dataset.tab;
      loginForm.style.display = target === 'login' ? 'flex' : 'none';
      registerForm.style.display = target === 'register' ? 'flex' : 'none';
      messageEl.textContent = '';
    });
  });

  // æ¨¡æ‹Ÿç”¨æˆ·å­˜å‚¨ï¼ˆå®é™…åº”ä½¿ç”¨åç«¯ï¼‰
  let users = JSON.parse(localStorage.getItem('gameUsers') || '[]');

  // æ³¨å†Œ
  registerForm.addEventListener('submit', (e) => {
    e.preventDefault();
    const username = document.getElementById('reg-username').value.trim();
    const password = document.getElementById('reg-password').value;
    const confirm = document.getElementById('reg-confirm').value;

    if (password !== confirm) {
      showMessage('ä¸¤æ¬¡å¯†ç ä¸ä¸€è‡´ï¼', true);
      return;
    }
    if (users.some(u => u.username === username)) {
      showMessage('ç”¨æˆ·åå·²å­˜åœ¨ï¼', true);
      return;
    }
    users.push({ username, password });
    localStorage.setItem('gameUsers', JSON.stringify(users));
    showMessage('æ³¨å†ŒæˆåŠŸï¼è¯·ç™»å½•ã€‚', false);
    // è‡ªåŠ¨åˆ‡æ¢åˆ°ç™»å½•
    tabs[0].click();
    registerForm.reset();
  });

  // ç™»å½•
  loginForm.addEventListener('submit', (e) => {
    e.preventDefault();
    const username = document.getElementById('login-username').value.trim();
    const password = document.getElementById('login-password').value;

    const user = users.find(u => u.username === username && u.password === password);
    if (user) {
      showMessage('ç™»å½•æˆåŠŸï¼è¿›å…¥æ¸¸æˆ...', false);
      setTimeout(() => {
        authScreen.style.display = 'none';
        document.getElementById('start-screen').style.display = 'flex';
        document.body.classList.add('prestart');
      }, 800);
    } else {
      showMessage('ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯ï¼', true);
    }
  });

  function showMessage(text, isError) {
    messageEl.textContent = text;
    messageEl.style.color = isError ? '#ff8fab' : '#a8e6cf';
  }
});

// åˆå§‹åŒ–æ¸¸æˆ
function initializeGame() {
    try {
        // åˆ›å»ºå…¨å±€gameå®ä¾‹
        game = new Game();
        
        // åˆå§‹åŒ–æ—¶é—´å‡ç¼“è¦†ç›–å±‚
        const timeSlowOverlay = document.getElementById('time-slow-overlay');
        if (timeSlowOverlay) {
            timeSlowOverlay.style.opacity = '0';
        }

        // ç¡®ä¿æŠ€èƒ½æŒ‰é”®å¯è§
        const skillHotkeys = document.querySelector('.skill-hotkeys');
        if (skillHotkeys) {
            skillHotkeys.style.display = 'flex';
        }
        
        // åˆå§‹åŒ–æ ‡é¢˜ç‰¹æ•ˆ
        window.addEventListener('load', initTitleEffects);
        
        console.log('æ¸¸æˆç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ');
    } catch (error) {
        console.error('æ¸¸æˆåˆå§‹åŒ–å¤±è´¥:', error);
        alert('æ¸¸æˆåˆå§‹åŒ–å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
    }
}

// é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–æ¸¸æˆ
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeGame);
} else {
    initializeGame();
}

// å¯¼å‡ºå…¨å±€å˜é‡
window.SkillSystem = SkillSystem;
window.game = game;
</script>
</body>
</html>